---
title: File Encryption Tool with Advanced Security
description: A professional file encryption and decryption tool using AES-256 encryption with secure key derivation, file integrity verification, and batch processing capabilities. Features password-based encryption, digital signatures, and secure file handling.
sidebar: 
    order: 56
hero:
  actions:
    - text: View on GitHub
      link: https://github.com/Ravikisha/PythonCentralHub/blob/main/projects/intermediate/fileencryption.py
      icon: github
      variant: primary
---
import FileCode from '../../../../components/FileCode.astro'

## Abstract

Create a professional file encryption and decryption tool that provides enterprise-grade security using AES-256 encryption with PBKDF2 key derivation. This project demonstrates advanced cryptography concepts, secure password handling, file integrity verification, and batch processing capabilities.

## Prerequisites

- Python 3.7 or above
- Text Editor or IDE
- Solid understanding of Python syntax and OOP concepts
- Knowledge of cryptography and security principles
- Familiarity with file handling and system operations
- Understanding of password security and key derivation
- Basic knowledge of encryption algorithms and best practices

## Getting Started

### Create a new project
1. Create a new project folder and name it `fileEncryptionTool`.
2. Create a new file and name it `fileencryption.py`.
3. Install required dependencies: `pip install cryptography`
4. Open the project folder in your favorite text editor or IDE.
5. Copy the code below and paste it into your `fileencryption.py` file.

### Write the code
1. Add the following code to your `fileencryption.py` file.
<FileCode file="projects/intermediate/fileencryption.py" lang="python" title="File Encryption Tool with Advanced Security" />
2. Save the file.
3. Run the following command to run the application.
```cmd title="command" showLineNumbers{1}
C:\Users\username\Documents\fileEncryptionTool> python fileencryption.py
File Encryption Tool
===================
1. Encrypt a file
2. Decrypt a file
3. Batch encrypt directory
4. Generate secure password
5. Exit
Choose option: 1
Enter file path: document.pdf
Enter password: [hidden input]
✓ File encrypted successfully: document.pdf.enc
File hash: a1b2c3d4e5f6...
```

## Explanation

1. The `from cryptography.fernet import Fernet` imports the Fernet symmetric encryption library.
2. The `PBKDF2HMAC` class provides secure password-based key derivation functionality.
3. The `FileEncryption` class manages all encryption and decryption operations.
4. The `generate_key_from_password()` method derives encryption keys from user passwords.
5. The `encrypt_file()` method encrypts individual files with secure key handling.
6. The `decrypt_file()` method reverses the encryption process to restore original files.
7. Salt generation ensures unique keys even with identical passwords.
8. File integrity verification uses SHA-256 hashing to detect corruption.
9. Batch processing enables encryption of multiple files or entire directories.
10. Secure password input prevents password exposure in command history.
11. Progress tracking provides feedback for large file operations.
12. Error handling manages file access issues and encryption failures.

## Next Steps

Congratulations! You have successfully created a File Encryption Tool in Python. Experiment with the code and see if you can modify the application. Here are a few suggestions:
- Add GUI interface with drag-and-drop functionality
- Implement digital signatures for file authentication
- Create secure file shredding for original files
- Add compression before encryption for space efficiency
- Implement key escrow and recovery mechanisms
- Create encrypted archive functionality
- Add steganography features for hidden encryption
- Implement cloud storage integration with encryption
- Create secure file sharing with key exchange

## Conclusion

In this project, you learned how to create a File Encryption Tool in Python using advanced cryptography. You also learned about secure key derivation, file integrity verification, password security, and implementing enterprise-grade encryption solutions. You can find the source code on [GitHub](https://github.com/Ravikisha/PythonCentralHub/blob/main/projects/intermediate/fileencryption.py)

## How It Works

### 1. Cryptographic Foundation
```python title="fileencryption.py" showLineNumbers{1}
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.hashes import SHA256
from cryptography.hazmat.primitives.padding import PKCS7
from cryptography.hazmat.backends import default_backend
import os
import secrets

class FileEncryption:
    def __init__(self):
        self.algorithm = algorithms.AES
        self.key_size = 32  # 256 bits
        self.iv_size = 16   # 128 bits
        self.salt_size = 32 # 256 bits
        self.iterations = 100000  # PBKDF2 iterations
        self.backend = default_backend()
```

The encryption system uses:
- **AES-256-CBC**: Advanced Encryption Standard with 256-bit key
- **PBKDF2**: Password-Based Key Derivation Function 2
- **Random Salt**: Unique salt for each encryption
- **PKCS7 Padding**: Standard padding for block ciphers
- **Secure Random**: Cryptographically secure random number generation

### 2. Key Derivation Process
```python title="fileencryption.py" showLineNumbers{1}
def derive_key_from_password(self, password: str, salt: bytes) -> bytes:
    """Derive encryption key from password using PBKDF2"""
    password_bytes = password.encode('utf-8')
    
    kdf = PBKDF2HMAC(
        algorithm=SHA256(),
        length=self.key_size,
        salt=salt,
        iterations=self.iterations,
        backend=self.backend
    )
    
    return kdf.derive(password_bytes)

def generate_salt(self) -> bytes:
    """Generate cryptographically secure random salt"""
    return secrets.token_bytes(self.salt_size)

def generate_iv(self) -> bytes:
    """Generate cryptographically secure random IV"""
    return secrets.token_bytes(self.iv_size)
```

### 3. Encryption Implementation
```python title="fileencryption.py" showLineNumbers{1}
def encrypt_file(self, input_file_path: str, output_file_path: str, 
                password: str, preserve_metadata: bool = True) -> dict:
    """Encrypt a file with AES-256-CBC"""
    try:
        # Generate cryptographic parameters
        salt = self.generate_salt()
        iv = self.generate_iv()
        key = self.derive_key_from_password(password, salt)
        
        # Create cipher
        cipher = Cipher(
            self.algorithm(key),
            modes.CBC(iv),
            backend=self.backend
        )
        encryptor = cipher.encryptor()
        
        # Initialize padding
        padder = PKCS7(128).padder()
        
        # File size for progress tracking
        file_size = os.path.getsize(input_file_path)
        processed_size = 0
        
        # Create encrypted file header
        header = self._create_file_header(salt, iv, preserve_metadata, input_file_path)
        
        with open(input_file_path, 'rb') as infile, \
             open(output_file_path, 'wb') as outfile:
            
            # Write header
            outfile.write(header)
            
            # Encrypt file content in chunks
            chunk_size = 64 * 1024  # 64KB chunks
            while True:
                chunk = infile.read(chunk_size)
                if not chunk:
                    break
                
                processed_size += len(chunk)
                
                # Pad the last chunk if necessary
                if len(chunk) < chunk_size:
                    padded_chunk = padder.update(chunk)
                    padded_chunk += padder.finalize()
                    encrypted_chunk = encryptor.update(padded_chunk)
                    encrypted_chunk += encryptor.finalize()
                else:
                    padded_chunk = padder.update(chunk)
                    encrypted_chunk = encryptor.update(padded_chunk)
                
                outfile.write(encrypted_chunk)
                
                # Progress callback
                if hasattr(self, 'progress_callback'):
                    self.progress_callback(processed_size, file_size)
        
        # Calculate file hash for integrity verification
        file_hash = self._calculate_file_hash(output_file_path)
        
        return {
            'success': True,
            'input_file': input_file_path,
            'output_file': output_file_path,
            'file_size': file_size,
            'encrypted_size': os.path.getsize(output_file_path),
            'hash': file_hash
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': str(e),
            'input_file': input_file_path
        }
```

### 4. Decryption Implementation
```python title="fileencryption.py" showLineNumbers{1}
def decrypt_file(self, input_file_path: str, output_file_path: str, 
                password: str) -> dict:
    """Decrypt a file encrypted with AES-256-CBC"""
    try:
        with open(input_file_path, 'rb') as infile:
            # Read and parse header
            header_data = self._read_file_header(infile)
            salt = header_data['salt']
            iv = header_data['iv']
            
            # Derive key from password
            key = self.derive_key_from_password(password, salt)
            
            # Create cipher
            cipher = Cipher(
                self.algorithm(key),
                modes.CBC(iv),
                backend=self.backend
            )
            decryptor = cipher.decryptor()
            
            # Initialize unpadding
            unpadder = PKCS7(128).unpadder()
            
            file_size = os.path.getsize(input_file_path)
            processed_size = len(header_data['raw_header'])
            
            with open(output_file_path, 'wb') as outfile:
                # Decrypt file content in chunks
                chunk_size = 64 * 1024
                decrypted_chunks = []
                
                while True:
                    chunk = infile.read(chunk_size)
                    if not chunk:
                        break
                    
                    processed_size += len(chunk)
                    decrypted_chunk = decryptor.update(chunk)
                    decrypted_chunks.append(decrypted_chunk)
                    
                    # Progress callback
                    if hasattr(self, 'progress_callback'):
                        self.progress_callback(processed_size, file_size)
                
                # Finalize decryption
                decrypted_chunks.append(decryptor.finalize())
                
                # Combine all decrypted chunks
                all_decrypted = b''.join(decrypted_chunks)
                
                # Remove padding
                unpadded_data = unpadder.update(all_decrypted)
                unpadded_data += unpadder.finalize()
                
                outfile.write(unpadded_data)
        
        # Restore metadata if preserved
        if header_data.get('metadata'):
            self._restore_file_metadata(output_file_path, header_data['metadata'])
        
        return {
            'success': True,
            'input_file': input_file_path,
            'output_file': output_file_path,
            'original_size': os.path.getsize(output_file_path)
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': str(e),
            'input_file': input_file_path
        }
```

### 5. File Header Management
```python title="fileencryption.py" showLineNumbers{1}
def _create_file_header(self, salt: bytes, iv: bytes, preserve_metadata: bool, 
                       original_file: str) -> bytes:
    """Create encrypted file header with metadata"""
    import struct
    import json
    
    header = b'PYENC'  # File signature
    header += struct.pack('<I', 1)  # Version number
    header += salt  # 32 bytes
    header += iv    # 16 bytes
    
    metadata = {}
    if preserve_metadata:
        stat = os.stat(original_file)
        metadata = {
            'original_name': os.path.basename(original_file),
            'size': stat.st_size,
            'mtime': stat.st_mtime,
            'mode': stat.st_mode
        }
    
    metadata_json = json.dumps(metadata).encode('utf-8')
    header += struct.pack('<I', len(metadata_json))
    header += metadata_json
    
    # Header checksum
    import hashlib
    checksum = hashlib.sha256(header).digest()[:8]
    header += checksum
    
    return header

def _read_file_header(self, file_handle) -> dict:
    """Read and validate encrypted file header"""
    import struct
    import json
    
    # Read signature
    signature = file_handle.read(5)
    if signature != b'PYENC':
        raise ValueError("Invalid encrypted file format")
    
    # Read version
    version = struct.unpack('<I', file_handle.read(4))[0]
    if version != 1:
        raise ValueError(f"Unsupported file version: {version}")
    
    # Read salt and IV
    salt = file_handle.read(32)
    iv = file_handle.read(16)
    
    # Read metadata
    metadata_length = struct.unpack('<I', file_handle.read(4))[0]
    metadata_json = file_handle.read(metadata_length)
    metadata = json.loads(metadata_json.decode('utf-8'))
    
    # Read and verify checksum
    stored_checksum = file_handle.read(8)
    
    # Calculate header for verification
    header_data = signature + struct.pack('<I', version) + salt + iv + \
                 struct.pack('<I', metadata_length) + metadata_json
    
    import hashlib
    calculated_checksum = hashlib.sha256(header_data).digest()[:8]
    
    if stored_checksum != calculated_checksum:
        raise ValueError("File header corruption detected")
    
    return {
        'salt': salt,
        'iv': iv,
        'metadata': metadata,
        'raw_header': header_data + stored_checksum
    }
```

## Batch Processing

### 1. Multiple File Encryption
```python title="fileencryption.py" showLineNumbers{1}
def encrypt_batch(self, file_list: list, output_directory: str, 
                 password: str, preserve_metadata: bool = True) -> dict:
    """Encrypt multiple files in batch"""
    results = {
        'successful': [],
        'failed': [],
        'total_files': len(file_list),
        'total_size': 0,
        'start_time': time.time()
    }
    
    for i, file_path in enumerate(file_list):
        try:
            if not os.path.isfile(file_path):
                results['failed'].append({
                    'file': file_path,
                    'error': 'File not found'
                })
                continue
            
            # Generate output filename
            base_name = os.path.basename(file_path)
            output_file = os.path.join(output_directory, f"{base_name}.enc")
            
            # Progress callback for batch processing
            def batch_progress(processed, total):
                overall_progress = ((i * 100) + (processed / total * 100)) / len(file_list)
                if hasattr(self, 'batch_progress_callback'):
                    self.batch_progress_callback(overall_progress, i + 1, len(file_list))
            
            self.progress_callback = batch_progress
            
            # Encrypt file
            result = self.encrypt_file(file_path, output_file, password, preserve_metadata)
            
            if result['success']:
                results['successful'].append(result)
                results['total_size'] += result['file_size']
            else:
                results['failed'].append(result)
                
        except Exception as e:
            results['failed'].append({
                'file': file_path,
                'error': str(e)
            })
    
    results['end_time'] = time.time()
    results['duration'] = results['end_time'] - results['start_time']
    
    return results

def decrypt_batch(self, file_list: list, output_directory: str, 
                 password: str) -> dict:
    """Decrypt multiple files in batch"""
    results = {
        'successful': [],
        'failed': [],
        'total_files': len(file_list),
        'start_time': time.time()
    }
    
    for i, file_path in enumerate(file_list):
        try:
            if not os.path.isfile(file_path):
                results['failed'].append({
                    'file': file_path,
                    'error': 'File not found'
                })
                continue
            
            # Generate output filename
            base_name = os.path.basename(file_path)
            if base_name.endswith('.enc'):
                output_name = base_name[:-4]  # Remove .enc extension
            else:
                output_name = f"{base_name}.decrypted"
            
            output_file = os.path.join(output_directory, output_name)
            
            # Progress callback for batch processing
            def batch_progress(processed, total):
                overall_progress = ((i * 100) + (processed / total * 100)) / len(file_list)
                if hasattr(self, 'batch_progress_callback'):
                    self.batch_progress_callback(overall_progress, i + 1, len(file_list))
            
            self.progress_callback = batch_progress
            
            # Decrypt file
            result = self.decrypt_file(file_path, output_file, password)
            
            if result['success']:
                results['successful'].append(result)
            else:
                results['failed'].append(result)
                
        except Exception as e:
            results['failed'].append({
                'file': file_path,
                'error': str(e)
            })
    
    results['end_time'] = time.time()
    results['duration'] = results['end_time'] - results['start_time']
    
    return results
```

### 2. Directory Encryption
```python title="fileencryption.py" showLineNumbers{1}
def encrypt_directory(self, directory_path: str, output_directory: str, 
                     password: str, recursive: bool = True) -> dict:
    """Encrypt all files in a directory"""
    import glob
    
    if recursive:
        pattern = os.path.join(directory_path, '**', '*')
        file_list = [f for f in glob.glob(pattern, recursive=True) if os.path.isfile(f)]
    else:
        pattern = os.path.join(directory_path, '*')
        file_list = [f for f in glob.glob(pattern) if os.path.isfile(f)]
    
    # Create output directory structure
    for file_path in file_list:
        relative_path = os.path.relpath(file_path, directory_path)
        output_file_dir = os.path.join(output_directory, os.path.dirname(relative_path))
        os.makedirs(output_file_dir, exist_ok=True)
    
    return self.encrypt_batch(file_list, output_directory, password)
```

## Security Features

### 1. Password Strength Validation
```python title="fileencryption.py" showLineNumbers{1}
def validate_password_strength(self, password: str) -> dict:
    """Validate password strength for encryption"""
    issues = []
    score = 0
    
    # Length check
    if len(password) < 8:
        issues.append("Password must be at least 8 characters long")
    elif len(password) >= 12:
        score += 2
    else:
        score += 1
    
    # Character variety checks
    if not any(c.isupper() for c in password):
        issues.append("Password should contain uppercase letters")
    else:
        score += 1
    
    if not any(c.islower() for c in password):
        issues.append("Password should contain lowercase letters")
    else:
        score += 1
    
    if not any(c.isdigit() for c in password):
        issues.append("Password should contain numbers")
    else:
        score += 1
    
    if not any(c in '!@#$%^&*()_+-=[]{}|;:,.<>?' for c in password):
        issues.append("Password should contain special characters")
    else:
        score += 1
    
    # Common password check
    common_passwords = ['password', '123456', 'qwerty', 'admin', 'letmein']
    if password.lower() in common_passwords:
        issues.append("Password is too common")
        score = 0
    
    strength_levels = {
        0: 'Very Weak',
        1: 'Weak', 
        2: 'Fair',
        3: 'Good',
        4: 'Strong',
        5: 'Very Strong',
        6: 'Excellent'
    }
    
    return {
        'score': score,
        'strength': strength_levels.get(score, 'Unknown'),
        'issues': issues,
        'is_acceptable': score >= 3 and len(issues) == 0
    }
```

### 2. Secure Memory Handling
```python title="fileencryption.py" showLineNumbers{1}
class SecureString:
    """Secure string class for handling passwords in memory"""
    
    def __init__(self, data: str):
        self._data = bytearray(data.encode('utf-8'))
    
    def get(self) -> str:
        """Get the string value"""
        return bytes(self._data).decode('utf-8')
    
    def clear(self):
        """Securely clear the string from memory"""
        for i in range(len(self._data)):
            self._data[i] = 0
    
    def __del__(self):
        """Ensure cleanup on deletion"""
        if hasattr(self, '_data'):
            self.clear()

def get_secure_password() -> SecureString:
    """Securely prompt for password"""
    import getpass
    
    while True:
        password = getpass.getpass("Enter encryption password: ")
        confirm = getpass.getpass("Confirm password: ")
        
        if password != confirm:
            print("Passwords do not match. Please try again.")
            continue
        
        # Validate password strength
        validation = FileEncryption().validate_password_strength(password)
        
        if not validation['is_acceptable']:
            print(f"Password strength: {validation['strength']}")
            for issue in validation['issues']:
                print(f"- {issue}")
            
            continue_anyway = input("Continue with weak password? (y/N): ").lower()
            if continue_anyway != 'y':
                continue
        
        return SecureString(password)
```

### 3. File Integrity Verification
```python title="fileencryption.py" showLineNumbers{1}
def _calculate_file_hash(self, file_path: str) -> str:
    """Calculate SHA-256 hash of file for integrity verification"""
    import hashlib
    
    hasher = hashlib.sha256()
    with open(file_path, 'rb') as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hasher.update(chunk)
    
    return hasher.hexdigest()

def verify_file_integrity(self, file_path: str, expected_hash: str) -> bool:
    """Verify file integrity using SHA-256 hash"""
    actual_hash = self._calculate_file_hash(file_path)
    return actual_hash.lower() == expected_hash.lower()

def create_digital_signature(self, file_path: str, private_key_path: str) -> bytes:
    """Create digital signature for file integrity"""
    from cryptography.hazmat.primitives import serialization, hashes
    from cryptography.hazmat.primitives.asymmetric import rsa, padding
    
    # Load private key
    with open(private_key_path, 'rb') as key_file:
        private_key = serialization.load_pem_private_key(
            key_file.read(),
            password=None,
            backend=self.backend
        )
    
    # Calculate file hash
    file_hash = self._calculate_file_hash(file_path)
    
    # Create signature
    signature = private_key.sign(
        file_hash.encode('utf-8'),
        padding.PSS(
            mgf=padding.MGF1(hashes.SHA256()),
            salt_length=padding.PSS.MAX_LENGTH
        ),
        hashes.SHA256()
    )
    
    return signature
```

## Command Line Interface

### 1. CLI Implementation
```python title="fileencryption.py" showLineNumbers{1}
import argparse
import sys
from pathlib import Path

class FileEncryptionCLI:
    def __init__(self):
        self.encryptor = FileEncryption()
        self.setup_progress_callbacks()
    
    def setup_progress_callbacks(self):
        """Setup progress tracking for CLI"""
        try:
            from tqdm import tqdm
            self.use_tqdm = True
        except ImportError:
            self.use_tqdm = False
        
        self.current_progress_bar = None
    
    def progress_callback(self, processed: int, total: int):
        """Progress callback for single file operations"""
        if self.use_tqdm:
            if self.current_progress_bar is None:
                self.current_progress_bar = tqdm(total=total, unit='B', unit_scale=True)
            
            self.current_progress_bar.update(processed - self.current_progress_bar.n)
            
            if processed >= total:
                self.current_progress_bar.close()
                self.current_progress_bar = None
        else:
            percentage = (processed / total) * 100
            sys.stdout.write(f"\rProgress: {percentage:.1f}%")
            sys.stdout.flush()
            
            if processed >= total:
                print()  # New line when complete
    
    def main(self):
        """Main CLI entry point"""
        parser = argparse.ArgumentParser(description='File Encryption Tool')
        parser.add_argument('action', choices=['encrypt', 'decrypt', 'batch-encrypt', 'batch-decrypt'],
                          help='Action to perform')
        parser.add_argument('-i', '--input', required=True,
                          help='Input file or directory path')
        parser.add_argument('-o', '--output', required=True,
                          help='Output file or directory path')
        parser.add_argument('-p', '--password', 
                          help='Encryption password (will prompt if not provided)')
        parser.add_argument('--no-metadata', action='store_true',
                          help='Do not preserve file metadata')
        parser.add_argument('-r', '--recursive', action='store_true',
                          help='Process directories recursively')
        parser.add_argument('--verify', action='store_true',
                          help='Verify file integrity after operation')
        
        args = parser.parse_args()
        
        # Get password securely
        if args.password:
            password = args.password
        else:
            password = get_secure_password().get()
        
        # Set progress callback
        self.encryptor.progress_callback = self.progress_callback
        
        try:
            if args.action == 'encrypt':
                result = self.encrypt_single_file(args.input, args.output, password, 
                                                not args.no_metadata)
            elif args.action == 'decrypt':
                result = self.decrypt_single_file(args.input, args.output, password)
            elif args.action == 'batch-encrypt':
                result = self.batch_encrypt_files(args.input, args.output, password,
                                                not args.no_metadata, args.recursive)
            elif args.action == 'batch-decrypt':
                result = self.batch_decrypt_files(args.input, args.output, password,
                                                args.recursive)
            
            self.print_results(result)
            
        except KeyboardInterrupt:
            print("\nOperation cancelled by user")
            sys.exit(1)
        except Exception as e:
            print(f"Error: {e}")
            sys.exit(1)
    
    def encrypt_single_file(self, input_file: str, output_file: str, 
                          password: str, preserve_metadata: bool) -> dict:
        """Encrypt a single file"""
        print(f"Encrypting: {input_file}")
        result = self.encryptor.encrypt_file(input_file, output_file, password, preserve_metadata)
        
        if result['success']:
            print(f"✓ Successfully encrypted to: {output_file}")
            print(f"  Original size: {self.format_size(result['file_size'])}")
            print(f"  Encrypted size: {self.format_size(result['encrypted_size'])}")
            print(f"  File hash: {result['hash']}")
        else:
            print(f"✗ Encryption failed: {result['error']}")
        
        return result
    
    def decrypt_single_file(self, input_file: str, output_file: str, password: str) -> dict:
        """Decrypt a single file"""
        print(f"Decrypting: {input_file}")
        result = self.encryptor.decrypt_file(input_file, output_file, password)
        
        if result['success']:
            print(f"✓ Successfully decrypted to: {output_file}")
            print(f"  Decrypted size: {self.format_size(result['original_size'])}")
        else:
            print(f"✗ Decryption failed: {result['error']}")
        
        return result
    
    @staticmethod
    def format_size(size_bytes: int) -> str:
        """Format file size in human readable format"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.1f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.1f} PB"
    
    def print_results(self, result: dict):
        """Print operation results"""
        if isinstance(result, dict) and 'successful' in result:
            # Batch operation results
            print(f"\nBatch operation completed:")
            print(f"  Successful: {len(result['successful'])}")
            print(f"  Failed: {len(result['failed'])}")
            print(f"  Duration: {result['duration']:.2f} seconds")
            
            if result['failed']:
                print("\nFailed files:")
                for failed in result['failed']:
                    print(f"  ✗ {failed['file']}: {failed['error']}")

if __name__ == "__main__":
    cli = FileEncryptionCLI()
    cli.main()
```

## GUI Interface

### 1. Tkinter GUI Implementation
```python title="fileencryption.py" showLineNumbers{1}
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import threading

class FileEncryptionGUI:
    def __init__(self):
        self.encryptor = FileEncryption()
        self.setup_gui()
        
    def setup_gui(self):
        """Setup the GUI interface"""
        self.root = tk.Tk()
        self.root.title("File Encryption Tool")
        self.root.geometry("600x500")
        self.root.resizable(True, True)
        
        # Create main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        
        # File selection
        ttk.Label(main_frame, text="Select Files:").grid(row=0, column=0, sticky=tk.W, pady=5)
        
        self.file_list = tk.Listbox(main_frame, height=8)
        self.file_list.grid(row=1, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=5)
        
        file_buttons_frame = ttk.Frame(main_frame)
        file_buttons_frame.grid(row=2, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Button(file_buttons_frame, text="Add Files", 
                  command=self.add_files).pack(side=tk.LEFT, padx=5)
        ttk.Button(file_buttons_frame, text="Add Directory", 
                  command=self.add_directory).pack(side=tk.LEFT, padx=5)
        ttk.Button(file_buttons_frame, text="Clear List", 
                  command=self.clear_files).pack(side=tk.LEFT, padx=5)
        
        # Output directory
        ttk.Label(main_frame, text="Output Directory:").grid(row=3, column=0, sticky=tk.W, pady=5)
        
        self.output_var = tk.StringVar()
        ttk.Entry(main_frame, textvariable=self.output_var).grid(row=4, column=0, columnspan=2, 
                                                                sticky=(tk.W, tk.E), pady=5)
        ttk.Button(main_frame, text="Browse", 
                  command=self.browse_output).grid(row=4, column=2, padx=5)
        
        # Password
        ttk.Label(main_frame, text="Password:").grid(row=5, column=0, sticky=tk.W, pady=5)
        
        self.password_var = tk.StringVar()
        self.password_entry = ttk.Entry(main_frame, textvariable=self.password_var, show="*")
        self.password_entry.grid(row=6, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        self.show_password_var = tk.BooleanVar()
        ttk.Checkbutton(main_frame, text="Show Password", variable=self.show_password_var,
                       command=self.toggle_password).grid(row=6, column=2, padx=5)
        
        # Options
        options_frame = ttk.LabelFrame(main_frame, text="Options", padding="5")
        options_frame.grid(row=7, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=10)
        
        self.preserve_metadata_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(options_frame, text="Preserve File Metadata", 
                       variable=self.preserve_metadata_var).pack(anchor=tk.W)
        
        self.recursive_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(options_frame, text="Process Directories Recursively", 
                       variable=self.recursive_var).pack(anchor=tk.W)
        
        # Action buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=8, column=0, columnspan=3, pady=20)
        
        self.encrypt_button = ttk.Button(button_frame, text="Encrypt Files", 
                                       command=self.encrypt_files)
        self.encrypt_button.pack(side=tk.LEFT, padx=10)
        
        self.decrypt_button = ttk.Button(button_frame, text="Decrypt Files", 
                                       command=self.decrypt_files)
        self.decrypt_button.pack(side=tk.LEFT, padx=10)
        
        # Progress bar
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(main_frame, variable=self.progress_var, 
                                          maximum=100)
        self.progress_bar.grid(row=9, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=10)
        
        # Status label
        self.status_var = tk.StringVar(value="Ready")
        ttk.Label(main_frame, textvariable=self.status_var).grid(row=10, column=0, columnspan=3)
    
    def add_files(self):
        """Add files to the list"""
        files = filedialog.askopenfilenames(title="Select Files to Encrypt/Decrypt")
        for file in files:
            self.file_list.insert(tk.END, file)
    
    def add_directory(self):
        """Add directory to the list"""
        directory = filedialog.askdirectory(title="Select Directory")
        if directory:
            self.file_list.insert(tk.END, f"[DIR] {directory}")
    
    def clear_files(self):
        """Clear the file list"""
        self.file_list.delete(0, tk.END)
    
    def browse_output(self):
        """Browse for output directory"""
        directory = filedialog.askdirectory(title="Select Output Directory")
        if directory:
            self.output_var.set(directory)
    
    def toggle_password(self):
        """Toggle password visibility"""
        if self.show_password_var.get():
            self.password_entry.config(show="")
        else:
            self.password_entry.config(show="*")
    
    def encrypt_files(self):
        """Encrypt selected files"""
        self.process_files("encrypt")
    
    def decrypt_files(self):
        """Decrypt selected files"""
        self.process_files("decrypt")
    
    def process_files(self, action):
        """Process files in background thread"""
        files = list(self.file_list.get(0, tk.END))
        output_dir = self.output_var.get()
        password = self.password_var.get()
        
        if not files:
            messagebox.showerror("Error", "Please select files to process")
            return
        
        if not output_dir:
            messagebox.showerror("Error", "Please select output directory")
            return
        
        if not password:
            messagebox.showerror("Error", "Please enter a password")
            return
        
        # Disable buttons during processing
        self.encrypt_button.config(state="disabled")
        self.decrypt_button.config(state="disabled")
        
        # Start processing in background thread
        thread = threading.Thread(target=self._process_files_worker, 
                                 args=(action, files, output_dir, password))
        thread.daemon = True
        thread.start()
    
    def _process_files_worker(self, action, files, output_dir, password):
        """Background worker for file processing"""
        try:
            # Setup progress callbacks
            def progress_callback(processed, total):
                percentage = (processed / total) * 100
                self.root.after(0, lambda: self.progress_var.set(percentage))
            
            def batch_progress_callback(overall_progress, current_file, total_files):
                self.root.after(0, lambda: self.status_var.set(
                    f"Processing file {current_file}/{total_files} ({overall_progress:.1f}%)"))
                self.root.after(0, lambda: self.progress_var.set(overall_progress))
            
            self.encryptor.progress_callback = progress_callback
            self.encryptor.batch_progress_callback = batch_progress_callback
            
            # Process files
            if action == "encrypt":
                result = self.encryptor.encrypt_batch(files, output_dir, password, 
                                                    self.preserve_metadata_var.get())
            else:
                result = self.encryptor.decrypt_batch(files, output_dir, password)
            
            # Show results
            self.root.after(0, lambda: self._show_results(result))
            
        except Exception as e:
            self.root.after(0, lambda: messagebox.showerror("Error", str(e)))
        finally:
            # Re-enable buttons
            self.root.after(0, lambda: self.encrypt_button.config(state="normal"))
            self.root.after(0, lambda: self.decrypt_button.config(state="normal"))
            self.root.after(0, lambda: self.progress_var.set(0))
            self.root.after(0, lambda: self.status_var.set("Ready"))
    
    def _show_results(self, result):
        """Show processing results"""
        message = f"Operation completed!\n\n"
        message += f"Successful: {len(result['successful'])}\n"
        message += f"Failed: {len(result['failed'])}\n"
        message += f"Duration: {result['duration']:.2f} seconds"
        
        if result['failed']:
            message += f"\n\nFailed files:\n"
            for failed in result['failed'][:5]:  # Show first 5 failures
                message += f"- {failed['file']}: {failed['error']}\n"
            
            if len(result['failed']) > 5:
                message += f"... and {len(result['failed']) - 5} more"
        
        messagebox.showinfo("Results", message)
    
    def run(self):
        """Run the GUI application"""
        self.root.mainloop()

# GUI entry point
def run_gui():
    app = FileEncryptionGUI()
    app.run()
```

## Running the Application

### Command Line Usage
```bash
# Encrypt a single file
python fileencryption.py encrypt -i document.pdf -o document.pdf.enc

# Decrypt a single file
python fileencryption.py decrypt -i document.pdf.enc -o document_decrypted.pdf

# Batch encrypt directory
python fileencryption.py batch-encrypt -i /path/to/files -o /path/to/encrypted --recursive

# Batch decrypt with password
python fileencryption.py batch-decrypt -i /path/to/encrypted -o /path/to/decrypted -p mypassword
```

### GUI Usage
```python title="fileencryption.py" showLineNumbers{1}
# Run the GUI interface
if __name__ == "__main__":
    run_gui()
```

### API Usage
```python title="fileencryption.py" showLineNumbers{1}
# Create encryptor instance
encryptor = FileEncryption()

# Encrypt a file
result = encryptor.encrypt_file(
    'important_document.pdf',
    'important_document.pdf.enc', 
    'my_secure_password'
)

# Decrypt a file
result = encryptor.decrypt_file(
    'important_document.pdf.enc',
    'important_document_decrypted.pdf',
    'my_secure_password'
)
```

## Sample Output

### Successful Encryption
```
=== File Encryption Tool ===
Encrypting: important_document.pdf
Progress: 100.0%
✓ Successfully encrypted to: important_document.pdf.enc
  Original size: 2.3 MB
  Encrypted size: 2.3 MB
  File hash: a1b2c3d4e5f6789012345678901234567890abcdef

Encryption completed in 0.45 seconds
```

### Batch Processing Results
```
Batch operation completed:
  Successful: 8
  Failed: 1
  Duration: 12.34 seconds

Failed files:
  ✗ /path/to/corrupted_file.txt: Permission denied
```

### Password Strength Validation
```
Password strength: Weak
- Password should contain uppercase letters
- Password should contain special characters

Continue with weak password? (y/N): n

Password strength: Strong
✓ Password accepted
```

## Security Considerations

### 1. Key Management Best Practices
```python title="fileencryption.py" showLineNumbers{1}
def secure_key_storage():
    """Best practices for key storage"""
    # DO NOT store passwords in plaintext
    # DO NOT hardcode passwords in source code
    # DO use environment variables for automation
    # DO prompt for passwords interactively
    # DO validate password strength
    # DO use secure memory handling
    pass

# Example of secure environment-based password
import os
def get_password_from_env():
    password = os.environ.get('ENCRYPTION_PASSWORD')
    if not password:
        raise ValueError("ENCRYPTION_PASSWORD environment variable not set")
    return password
```

### 2. Cryptographic Security Notes
```python title="fileencryption.py" showLineNumbers{1}
# Security features implemented:
# - AES-256-CBC encryption (industry standard)
# - PBKDF2 key derivation with 100,000 iterations
# - Cryptographically secure random salt and IV generation
# - PKCS7 padding for proper block alignment
# - SHA-256 file integrity verification
# - Secure header format with versioning
# - Protection against common attacks:
#   - Dictionary attacks (strong KDF)
#   - Rainbow table attacks (unique salts)
#   - Padding oracle attacks (authenticated encryption recommended)
```

### 3. File Security
```python title="fileencryption.py" showLineNumbers{1}
def secure_file_handling():
    """Security considerations for file handling"""
    # - Original files are not modified during encryption
    # - Temporary files are avoided when possible
    # - File permissions are preserved
    # - Metadata can be optionally encrypted
    # - Secure deletion of temporary data
    # - Progress tracking without data leakage
    pass
```

## Troubleshooting

### Common Issues

**1. Memory Issues with Large Files**
```python title="fileencryption.py" showLineNumbers{1}
# Solution: Process files in smaller chunks
def process_large_file(self, file_path, chunk_size=1024*1024):
    """Process large files in chunks to manage memory"""
    # Implementation uses streaming processing
    # Configurable chunk size based on available memory
    pass
```

**2. Permission Errors**
```python title="fileencryption.py" showLineNumbers{1}
# Solution: Check file permissions before processing
def check_file_permissions(self, file_path):
    """Check if file can be read/written"""
    try:
        with open(file_path, 'rb') as f:
            pass
        return True
    except PermissionError:
        return False
```

**3. Corrupted Files**
```python title="fileencryption.py" showLineNumbers{1}
# Solution: Verify file integrity
def verify_file_before_processing(self, file_path):
    """Verify file is not corrupted before processing"""
    try:
        # Check file header for encrypted files
        with open(file_path, 'rb') as f:
            signature = f.read(5)
            if signature == b'PYENC':
                # Verify header checksum
                header_data = self._read_file_header(f)
                return True
    except Exception:
        return False
```

## Performance Optimization

### 1. Multi-threading Support
```python title="fileencryption.py" showLineNumbers{1}
import concurrent.futures
import threading

def encrypt_batch_parallel(self, file_list, output_directory, password, 
                          max_workers=4):
    """Encrypt multiple files in parallel"""
    results = {'successful': [], 'failed': []}
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
        # Submit all encryption tasks
        future_to_file = {}
        for file_path in file_list:
            output_file = os.path.join(output_directory, 
                                     f"{os.path.basename(file_path)}.enc")
            future = executor.submit(self.encrypt_file, file_path, output_file, password)
            future_to_file[future] = file_path
        
        # Collect results
        for future in concurrent.futures.as_completed(future_to_file):
            file_path = future_to_file[future]
            try:
                result = future.result()
                if result['success']:
                    results['successful'].append(result)
                else:
                    results['failed'].append(result)
            except Exception as e:
                results['failed'].append({
                    'file': file_path,
                    'error': str(e)
                })
    
    return results
```

### 2. Memory Optimization
```python title="fileencryption.py" showLineNumbers{1}
def optimize_memory_usage(self):
    """Memory optimization strategies"""
    # Use streaming processing for large files
    # Process files in configurable chunks
    # Clear sensitive data from memory
    # Use memory-mapped files for very large files
    
    import mmap
    
    def process_with_mmap(self, file_path):
        """Use memory-mapped files for large file processing"""
        with open(file_path, 'rb') as f:
            with mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ) as mm:
                # Process memory-mapped file
                pass
```

## Extensions and Improvements

### 1. Cloud Storage Integration
```python title="fileencryption.py" showLineNumbers{1}
def encrypt_to_cloud(self, file_path, cloud_provider, credentials):
    """Encrypt and upload to cloud storage"""
    # Encrypt file locally
    encrypted_file = f"{file_path}.enc"
    result = self.encrypt_file(file_path, encrypted_file, password)
    
    if result['success']:
        # Upload to cloud (implementation depends on provider)
        cloud_upload(encrypted_file, cloud_provider, credentials)
        # Optionally remove local encrypted file
        os.remove(encrypted_file)
```

### 2. Key Escrow System
```python title="fileencryption.py" showLineNumbers{1}
def setup_key_escrow(self, escrow_public_key):
    """Setup key escrow for enterprise environments"""
    # Encrypt master key with escrow public key
    # Store encrypted master key separately
    # Allow key recovery by authorized personnel
    pass
```

### 3. Compression Integration
```python title="fileencryption.py" showLineNumbers{1}
def encrypt_with_compression(self, file_path, output_path, password, compress=True):
    """Encrypt with optional compression"""
    import gzip
    
    if compress:
        # Compress before encryption
        compressed_path = f"{file_path}.gz"
        with open(file_path, 'rb') as f_in:
            with gzip.open(compressed_path, 'wb') as f_out:
                f_out.writelines(f_in)
        
        # Encrypt compressed file
        result = self.encrypt_file(compressed_path, output_path, password)
        os.remove(compressed_path)  # Clean up
        return result
    else:
        return self.encrypt_file(file_path, output_path, password)
```

## Next Steps

After mastering this encryption tool, consider:

1. **Digital Signatures**: Add RSA/ECDSA signature support
2. **Key Management**: Implement proper key management system
3. **Cloud Integration**: Support for cloud storage encryption
4. **Enterprise Features**: Key escrow, policy management
5. **Mobile Apps**: Create mobile versions for file encryption

## Resources

- [Cryptography Library Documentation](https://cryptography.io/)
- [AES Encryption Standard](https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf)
- [PBKDF2 Specification](https://tools.ietf.org/html/rfc2898)
- [Python Security Best Practices](https://python-security.readthedocs.io/)
- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)

## Conclusion

This file encryption tool provides enterprise-grade security for protecting sensitive files using industry-standard encryption algorithms. It demonstrates advanced cryptographic concepts, secure programming practices, and professional software development techniques.

The tool combines security, usability, and performance to create a comprehensive solution for file protection. The modular design allows for easy extension and customization for specific security requirements. 🔒🐍
