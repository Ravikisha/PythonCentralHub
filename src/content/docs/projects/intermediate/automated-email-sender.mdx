---
title: Automated Email Sender with Advanced Features
description: A comprehensive email automation system with database management, contact grouping, template system, bulk sending capabilities, and GUI interface. Features SMTP configuration, attachment handling, scheduled sending, and detailed analytics.
sidebar: 
    order: 60
hero:
    actions:
        - text: View Source Code
          link: https://github.com/Ravikisha/PythonCentralHub/blob/main/projects/intermediate/automatedemailsender.py
          icon: external
          variant: primary
---
import FileCode from '../../../../components/FileCode.astro'

## Abstract

Create a professional automated email sender system that manages contacts, templates, and bulk email campaigns with advanced features. This project demonstrates email automation, database management, GUI development, and implementing enterprise-level email marketing capabilities.

## Prerequisites

- Python 3.7 or above
- Text Editor or IDE
- Solid understanding of Python syntax and OOP concepts
- Knowledge of email protocols (SMTP, IMAP)
- Familiarity with database operations and SQL
- Understanding of GUI development with Tkinter
- Basic knowledge of email security and authentication

## Getting Started

### Create a new project
1. Create a new project folder and name it `automatedEmailSender`.
2. Create a new file and name it `automatedemailsender.py`.
3. Install required dependencies: `pip install tkinter sqlite3 smtplib email`
4. Open the project folder in your favorite text editor or IDE.
5. Copy the code below and paste it into your `automatedemailsender.py` file.

### Write the code
1. Add the following code to your `automatedemailsender.py` file.
<FileCode file="projects/intermediate/automatedemailsender.py" lang="python" title="Automated Email Sender with Advanced Features" />
2. Save the file.
3. Run the following command to run the application.
```cmd title="command" showLineNumbers{1}
C:\Users\username\Documents\automatedEmailSender> python automatedemailsender.py
Email System Starting...
========================
âœ“ Database initialized
âœ“ GUI loaded
âœ“ SMTP configurations ready
âœ“ Template system active
Email Automation System Ready!
```

## Explanation

1. The `EmailDatabase` class manages SQLite database operations for contacts, templates, and accounts.
2. The `EmailSender` class handles SMTP connections and email sending functionality.
3. The `EmailScheduler` class provides automated scheduling and recurring email capabilities.
4. The `EmailGUI` class creates a comprehensive Tkinter interface for email management.
5. Database tables store email accounts, templates, contacts, and sending history.
6. Template system supports variable replacement and HTML/plain text formats.
7. Contact management includes grouping and CSV import functionality.
8. Bulk sending with progress tracking and error handling.
9. SMTP auto-detection for common email providers.
10. Attachment handling with file validation and size limits.
11. Email analytics and delivery tracking.
12. Security features including password encryption and authentication.

## Next Steps

Congratulations! You have successfully created an Automated Email Sender in Python. Experiment with the code and see if you can modify the application. Here are a few suggestions:
- Add email template editor with rich text formatting
- Implement email bounce handling and unsubscribe management
- Create email campaign analytics and reporting
- Add integration with popular email services (SendGrid, Mailchimp)
- Implement A/B testing for email campaigns
- Create email list segmentation and targeting
- Add email tracking pixels and click analytics
- Implement email scheduling with time zones
- Create backup and restore functionality for email data

## Conclusion

In this project, you learned how to create an Automated Email Sender in Python using advanced email automation concepts. You also learned about SMTP protocols, database management, contact organization, template systems, and implementing professional email marketing solutions. You can find the source code on [GitHub](https://github.com/Ravikisha/PythonCentralHub/blob/main/projects/intermediate/automatedemailsender.py)

## How It Works

### 1. Database Architecture
```python title="automatedemailsender.py" showLineNumbers{1}
class EmailDatabase:
    def __init__(self, db_path: str = "email_system.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        with sqlite3.connect(self.db_path) as conn:
            # Create accounts table
            conn.execute('''
                CREATE TABLE IF NOT EXISTS accounts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    email TEXT UNIQUE NOT NULL,
                    smtp_server TEXT NOT NULL,
                    smtp_port INTEGER NOT NULL
                )
            ''')
```

The database system includes:
- **Account Management**: Store SMTP configurations and credentials
- **Contact Organization**: Group contacts with custom fields
- **Template System**: Save reusable email templates
- **Analytics Tracking**: Monitor email delivery and engagement
- **History Logging**: Track all sent emails and results

### 2. Email Sending Engine
```python title="automatedemailsender.py" showLineNumbers{1}
class EmailSender:
    def __init__(self, database: EmailDatabase):
        self.db = database
    
    def send_email(self, account: EmailAccount, password: str, to_email: str, 
                   subject: str, body: str, is_html: bool = False, 
                   attachments: List[str] = None, to_name: str = "") -> Tuple[bool, str]:
        try:
            msg = MIMEMultipart()
            msg['From'] = account.email
            msg['To'] = to_email
            msg['Subject'] = subject
```

### 3. Template Management
```python title="automatedemailsender.py" showLineNumbers{1}
@dataclass
class EmailTemplate:
    name: str
    subject: str
    body: str
    is_html: bool = False
    variables: List[str] = None

def replace_variables(self, text: str, data: Dict) -> str:
    for key, value in data.items():
        placeholder = f"{{{key}}}"
        text = text.replace(placeholder, str(value))
    return text
```

### 4. Bulk Email Processing
```python title="automatedemailsender.py" showLineNumbers{1}
def send_bulk_emails(self, account: EmailAccount, password: str, 
                    recipients: List[Dict], template: EmailTemplate,
                    attachments: List[str] = None, 
                    progress_callback=None) -> Dict:
    results = {'sent': 0, 'failed': 0, 'errors': []}
    
    for i, recipient in enumerate(recipients):
        try:
            personalized_subject = self.replace_variables(template.subject, recipient)
            personalized_body = self.replace_variables(template.body, recipient)
```

### 5. GUI Implementation
```python title="automatedemailsender.py" showLineNumbers{1}
class EmailGUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Email Automation System")
        self.root.geometry("1200x800")
        
        self.db = EmailDatabase()
        self.email_sender = EmailSender(self.db)
        self.scheduler = EmailScheduler(self.email_sender)
        
        self.setup_ui()
```

## Email Account Configuration

### 1. SMTP Settings for Popular Providers
```python title="automatedemailsender.py" showLineNumbers{1}
def get_smtp_settings(self, email: str) -> Dict:
    """Auto-detect SMTP settings for common providers"""
    domain = email.split('@')[1].lower()
    
    smtp_configs = {
        'gmail.com': {
            'smtp_server': 'smtp.gmail.com',
            'smtp_port': 587,
            'use_tls': True,
            'imap_server': 'imap.gmail.com',
            'imap_port': 993
        },
        'outlook.com': {
            'smtp_server': 'smtp-mail.outlook.com',
            'smtp_port': 587,
            'use_tls': True,
            'imap_server': 'outlook.office365.com',
            'imap_port': 993
        },
        'yahoo.com': {
            'smtp_server': 'smtp.mail.yahoo.com',
            'smtp_port': 587,
            'use_tls': True,
            'imap_server': 'imap.mail.yahoo.com',
            'imap_port': 993
        },
        'hotmail.com': {
            'smtp_server': 'smtp-mail.outlook.com',
            'smtp_port': 587,
            'use_tls': True,
            'imap_server': 'outlook.office365.com',
            'imap_port': 993
        }
    }
    
    return smtp_configs.get(domain, {
        'smtp_server': '',
        'smtp_port': 587,
        'use_tls': True
    })
```

### 2. Connection Testing
```python title="automatedemailsender.py" showLineNumbers{1}
def test_connection(self, account: EmailAccount, password: str) -> Tuple[bool, str]:
    """Test SMTP connection with provided credentials"""
    try:
        server = smtplib.SMTP(account.smtp_server, account.smtp_port)
        server.starttls() if account.use_tls else None
        server.login(account.email, password)
        server.quit()
        return True, "Connection successful"
    
    except smtplib.SMTPAuthenticationError:
        return False, "Authentication failed. Check email/password"
    except smtplib.SMTPServerDisconnected:
        return False, "Server connection failed"
    except Exception as e:
        return False, f"Connection error: {str(e)}"
```

## Template System Features

### 1. Variable Replacement Engine
```python title="automatedemailsender.py" showLineNumbers{1}
def replace_variables(self, text: str, data: Dict) -> str:
    """Advanced variable replacement with multiple formats"""
    import re
    
    # Replace {variable} format
    for key, value in data.items():
        patterns = [
            f"{{{key}}}",           # {name}
            f"{{{{ {key} }}}}",     # {{ name }}
            f"[{key}]",             # [name]
            f"%{key}%"              # %name%
        ]
        
        for pattern in patterns:
            text = text.replace(pattern, str(value))
    
    # Replace conditional blocks
    # Example: {if:premium}Premium content{endif}
    conditional_pattern = r'\{if:(\w+)\}(.*?)\{endif\}'
    
    def replace_conditional(match):
        condition = match.group(1)
        content = match.group(2)
        return content if data.get(condition) else ""
    
    text = re.sub(conditional_pattern, replace_conditional, text, flags=re.DOTALL)
    
    return text
```

### 2. Template Categories
```python title="automatedemailsender.py" showLineNumbers{1}
def get_template_categories(self) -> Dict:
    """Predefined template categories and examples"""
    return {
        'marketing': {
            'welcome_series': {
                'subject': 'Welcome to {company_name}, {first_name}!',
                'body': '''
Hello {first_name},

Welcome to {company_name}! We're excited to have you join our community.

Your account details:
- Email: {email}
- Member ID: {member_id}
- Join Date: {join_date}

Best regards,
{sender_name}
'''
            },
            'newsletter': {
                'subject': '{company_name} Newsletter - {month} {year}',
                'body': '''
Hi {first_name},

Here's what's new this month at {company_name}:

{newsletter_content}

Don't miss out on our special offers!

Unsubscribe: {unsubscribe_link}
'''
            }
        },
        'transactional': {
            'order_confirmation': {
                'subject': 'Order Confirmation #{order_id}',
                'body': '''
Dear {customer_name},

Thank you for your order!

Order Details:
- Order ID: {order_id}
- Total: {order_total}
- Estimated Delivery: {delivery_date}

Track your order: {tracking_link}
'''
            }
        },
        'notification': {
            'password_reset': {
                'subject': 'Password Reset Request',
                'body': '''
Hi {username},

You requested a password reset for your account.

Click here to reset: {reset_link}

This link expires in 24 hours.

If you didn't request this, please ignore this email.
'''
            }
        }
    }
```

## Contact Management System

### 1. CSV Import with Validation
```python title="automatedemailsender.py" showLineNumbers{1}
def parse_csv_contacts(self, csv_file_path: str) -> List[Dict]:
    """Parse and validate CSV contact file"""
    contacts = []
    errors = []
    
    try:
        with open(csv_file_path, 'r', encoding='utf-8') as file:
            reader = csv.DictReader(file)
            
            required_fields = ['email']
            optional_fields = ['first_name', 'last_name', 'company', 'phone']
            
            for row_num, row in enumerate(reader, start=2):
                # Validate required fields
                if not row.get('email') or not self.validate_email(row['email']):
                    errors.append(f"Row {row_num}: Invalid email address")
                    continue
                
                # Clean and format contact data
                contact = {
                    'email': row['email'].strip().lower(),
                    'first_name': row.get('first_name', '').strip(),
                    'last_name': row.get('last_name', '').strip(),
                    'full_name': f"{row.get('first_name', '')} {row.get('last_name', '')}".strip(),
                    'company': row.get('company', '').strip(),
                    'phone': row.get('phone', '').strip(),
                    'import_date': datetime.datetime.now().isoformat()
                }
                
                # Add any additional custom fields
                for key, value in row.items():
                    if key not in required_fields + optional_fields:
                        contact[f'custom_{key}'] = value
                
                contacts.append(contact)
        
        if errors:
            print(f"Import completed with {len(errors)} errors:")
            for error in errors[:10]:  # Show first 10 errors
                print(f"  - {error}")
    
    except Exception as e:
        print(f"Error reading CSV file: {e}")
    
    return contacts
```

### 2. Contact Segmentation
```python title="automatedemailsender.py" showLineNumbers{1}
def segment_contacts(self, criteria: Dict) -> List[Dict]:
    """Segment contacts based on criteria"""
    with sqlite3.connect(self.db_path) as conn:
        query_parts = ["SELECT * FROM contacts WHERE 1=1"]
        params = []
        
        if criteria.get('group_name'):
            query_parts.append("AND group_name = ?")
            params.append(criteria['group_name'])
        
        if criteria.get('company'):
            query_parts.append("AND company LIKE ?")
            params.append(f"%{criteria['company']}%")
        
        if criteria.get('has_custom_field'):
            field, value = criteria['has_custom_field']
            query_parts.append(f"AND custom_fields LIKE ?")
            params.append(f'%"{field}":"%{value}"%')
        
        if criteria.get('last_contacted_days'):
            days_ago = datetime.datetime.now() - datetime.timedelta(days=criteria['last_contacted_days'])
            query_parts.append("AND last_contacted > ?")
            params.append(days_ago.isoformat())
        
        cursor = conn.execute(" ".join(query_parts), params)
        contacts = [dict(zip([col[0] for col in cursor.description], row)) 
                   for row in cursor.fetchall()]
        
        return contacts
```

## Bulk Email Processing

### 1. Advanced Sending Engine
```python title="automatedemailsender.py" showLineNumbers{1}
def send_bulk_emails(self, account: EmailAccount, password: str, 
                    recipients: List[Dict], template: EmailTemplate,
                    attachments: List[str] = None, 
                    progress_callback=None) -> Dict:
    """Advanced bulk email sending with rate limiting and error handling"""
    results = {
        'sent': 0,
        'failed': 0,
        'errors': [],
        'start_time': datetime.datetime.now(),
        'end_time': None,
        'rate_limit_delays': 0
    }
    
    # Rate limiting settings
    emails_per_minute = 60
    delay_between_emails = 60 / emails_per_minute
    
    # Connection pool for efficiency
    server = None
    last_connect_time = 0
    reconnect_interval = 300  # Reconnect every 5 minutes
    
    try:
        for i, recipient in enumerate(recipients):
            # Reconnect if needed
            current_time = time.time()
            if not server or (current_time - last_connect_time) > reconnect_interval:
                if server:
                    server.quit()
                
                server = smtplib.SMTP(account.smtp_server, account.smtp_port)
                if account.use_tls:
                    server.starttls()
                server.login(account.email, password)
                last_connect_time = current_time
            
            # Personalize email content
            personalized_subject = self.replace_variables(template.subject, recipient)
            personalized_body = self.replace_variables(template.body, recipient)
            
            # Send email
            success, error_msg = self.send_single_email(
                server, account.email, recipient['email'], 
                personalized_subject, personalized_body, 
                template.is_html, attachments
            )
            
            if success:
                results['sent'] += 1
                self.log_sent_email(
                    account.email, recipient['email'], 
                    personalized_subject, True
                )
            else:
                results['failed'] += 1
                results['errors'].append({
                    'email': recipient['email'],
                    'error': error_msg
                })
                self.log_sent_email(
                    account.email, recipient['email'], 
                    personalized_subject, False, error_msg
                )
            
            # Progress callback
            if progress_callback:
                progress = ((i + 1) / len(recipients)) * 100
                progress_callback(progress, recipient['email'], success)
            
            # Rate limiting
            if i < len(recipients) - 1:  # Don't delay after last email
                time.sleep(delay_between_emails)
                if delay_between_emails > 0:
                    results['rate_limit_delays'] += 1
    
    except Exception as e:
        results['errors'].append({
            'email': 'bulk_operation',
            'error': f"Bulk operation failed: {str(e)}"
        })
    
    finally:
        if server:
            server.quit()
        results['end_time'] = datetime.datetime.now()
    
    return results
```

### 2. Email Scheduling System
```python title="automatedemailsender.py" showLineNumbers{1}
class EmailScheduler:
    def __init__(self, email_sender: EmailSender):
        self.email_sender = email_sender
        self.scheduled_tasks = []
        self.running = False
        self.scheduler_thread = None
    
    def schedule_email(self, account_id: int, template_id: int, 
                      recipient_group: str, schedule_time: str, 
                      repeat_type: str = "none", repeat_interval: int = 1):
        """Schedule email for future sending"""
        task = {
            'id': len(self.scheduled_tasks) + 1,
            'account_id': account_id,
            'template_id': template_id,
            'recipient_group': recipient_group,
            'schedule_time': datetime.datetime.fromisoformat(schedule_time),
            'repeat_type': repeat_type,  # none, daily, weekly, monthly
            'repeat_interval': repeat_interval,
            'next_run': datetime.datetime.fromisoformat(schedule_time),
            'created_at': datetime.datetime.now(),
            'status': 'scheduled'
        }
        
        self.scheduled_tasks.append(task)
        return task['id']
    
    def _run_scheduler(self):
        """Background scheduler execution"""
        while self.running:
            current_time = datetime.datetime.now()
            
            for task in self.scheduled_tasks:
                if (task['status'] == 'scheduled' and 
                    task['next_run'] <= current_time):
                    
                    # Execute the scheduled email
                    self._execute_scheduled_task(task)
                    
                    # Calculate next run if repeating
                    if task['repeat_type'] != 'none':
                        task['next_run'] = self._calculate_next_run(task)
                    else:
                        task['status'] = 'completed'
            
            time.sleep(60)  # Check every minute
    
    def _calculate_next_run(self, task: Dict) -> datetime.datetime:
        """Calculate next run time for repeating tasks"""
        current_next = task['next_run']
        interval = task['repeat_interval']
        
        if task['repeat_type'] == 'daily':
            return current_next + datetime.timedelta(days=interval)
        elif task['repeat_type'] == 'weekly':
            return current_next + datetime.timedelta(weeks=interval)
        elif task['repeat_type'] == 'monthly':
            # Approximate monthly calculation
            return current_next + datetime.timedelta(days=30 * interval)
        
        return current_next
```

## Analytics and Reporting

### 1. Email Performance Metrics
```python title="automatedemailsender.py" showLineNumbers{1}
def generate_email_analytics(self, account_id: int = None, 
                           days_back: int = 30) -> Dict:
    """Generate comprehensive email analytics"""
    with sqlite3.connect(self.db_path) as conn:
        # Base query conditions
        conditions = ["sent_at >= datetime('now', '-{} days')".format(days_back)]
        params = []
        
        if account_id:
            conditions.append("account_id = ?")
            params.append(account_id)
        
        where_clause = " AND ".join(conditions)
        
        # Total emails sent
        cursor = conn.execute(f"""
            SELECT COUNT(*) as total_sent,
                   COUNT(CASE WHEN success = 1 THEN 1 END) as successful,
                   COUNT(CASE WHEN success = 0 THEN 1 END) as failed
            FROM email_history 
            WHERE {where_clause}
        """, params)
        
        totals = cursor.fetchone()
        
        # Daily breakdown
        cursor = conn.execute(f"""
            SELECT date(sent_at) as send_date,
                   COUNT(*) as emails_sent,
                   COUNT(CASE WHEN success = 1 THEN 1 END) as successful
            FROM email_history 
            WHERE {where_clause}
            GROUP BY date(sent_at)
            ORDER BY send_date
        """, params)
        
        daily_stats = cursor.fetchall()
        
        # Top error types
        cursor = conn.execute(f"""
            SELECT error_message, COUNT(*) as error_count
            FROM email_history 
            WHERE {where_clause} AND success = 0 AND error_message IS NOT NULL
            GROUP BY error_message
            ORDER BY error_count DESC
            LIMIT 10
        """, params)
        
        error_stats = cursor.fetchall()
        
        # Template performance
        cursor = conn.execute(f"""
            SELECT template_id, COUNT(*) as usage_count,
                   COUNT(CASE WHEN success = 1 THEN 1 END) as successful_sends
            FROM email_history 
            WHERE {where_clause} AND template_id IS NOT NULL
            GROUP BY template_id
            ORDER BY usage_count DESC
        """, params)
        
        template_stats = cursor.fetchall()
        
        return {
            'summary': {
                'total_sent': totals[0],
                'successful': totals[1],
                'failed': totals[2],
                'success_rate': (totals[1] / totals[0] * 100) if totals[0] > 0 else 0,
                'period_days': days_back
            },
            'daily_breakdown': [
                {
                    'date': row[0],
                    'emails_sent': row[1],
                    'successful': row[2],
                    'success_rate': (row[2] / row[1] * 100) if row[1] > 0 else 0
                }
                for row in daily_stats
            ],
            'error_analysis': [
                {'error': row[0], 'count': row[1]}
                for row in error_stats
            ],
            'template_performance': [
                {
                    'template_id': row[0],
                    'usage_count': row[1],
                    'successful_sends': row[2],
                    'success_rate': (row[2] / row[1] * 100) if row[1] > 0 else 0
                }
                for row in template_stats
            ]
        }
```

### 2. Report Generation
```python title="automatedemailsender.py" showLineNumbers{1}
def generate_pdf_report(self, analytics: Dict, output_path: str):
    """Generate PDF analytics report"""
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.lib import colors
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    
    doc = SimpleDocTemplate(output_path, pagesize=A4)
    styles = getSampleStyleSheet()
    story = []
    
    # Title
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        alignment=1,  # Center alignment
        textColor=colors.darkblue
    )
    
    story.append(Paragraph("Email Campaign Analytics Report", title_style))
    story.append(Paragraph("<br/><br/>", styles['Normal']))
    
    # Summary section
    summary = analytics['summary']
    summary_data = [
        ['Metric', 'Value'],
        ['Total Emails Sent', f"{summary['total_sent']:,}"],
        ['Successful Sends', f"{summary['successful']:,}"],
        ['Failed Sends', f"{summary['failed']:,}"],
        ['Success Rate', f"{summary['success_rate']:.1f}%"],
        ['Reporting Period', f"{summary['period_days']} days"]
    ]
    
    summary_table = Table(summary_data)
    summary_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 14),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    
    story.append(Paragraph("Campaign Summary", styles['Heading2']))
    story.append(summary_table)
    story.append(Paragraph("<br/>", styles['Normal']))
    
    # Build PDF
    doc.build(story)
```

## Advanced Features

### 1. A/B Testing Framework
```python title="automatedemailsender.py" showLineNumbers{1}
class ABTestManager:
    def __init__(self, database: EmailDatabase):
        self.db = database
    
    def create_ab_test(self, test_name: str, template_a_id: int, 
                      template_b_id: int, test_percentage: float = 0.1):
        """Create A/B test for email templates"""
        with sqlite3.connect(self.db.db_path) as conn:
            conn.execute("""
                INSERT INTO ab_tests (test_name, template_a_id, template_b_id, 
                                    test_percentage, status, created_at)
                VALUES (?, ?, ?, ?, 'active', datetime('now'))
            """, (test_name, template_a_id, template_b_id, test_percentage))
            
            return conn.lastrowid
    
    def select_template_for_recipient(self, recipient_email: str, 
                                    available_tests: List[int]) -> int:
        """Select template based on A/B test assignment"""
        # Use email hash for consistent assignment
        email_hash = hash(recipient_email)
        
        for test_id in available_tests:
            test_info = self.get_test_info(test_id)
            
            # Determine if recipient is in test group
            hash_mod = abs(email_hash) % 100
            if hash_mod < (test_info['test_percentage'] * 100):
                # In test group - randomly assign template
                return test_info['template_b_id'] if hash_mod % 2 else test_info['template_a_id']
        
        # Default template if not in any test
        return available_tests[0] if available_tests else None
```

### 2. Email Validation and Verification
```python title="automatedemailsender.py" showLineNumbers{1}
def validate_email_list(self, email_list: List[str]) -> Dict:
    """Comprehensive email validation"""
    import re
    import dns.resolver
    
    results = {
        'valid': [],
        'invalid': [],
        'risky': [],
        'unknown': []
    }
    
    email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
    
    for email in email_list:
        email = email.strip().lower()
        
        # Basic format validation
        if not email_pattern.match(email):
            results['invalid'].append({
                'email': email,
                'reason': 'Invalid format'
            })
            continue
        
        # Domain validation
        domain = email.split('@')[1]
        
        try:
            # Check if domain has MX record
            mx_records = dns.resolver.resolve(domain, 'MX')
            
            if mx_records:
                # Additional checks for risky domains
                if self.is_disposable_email(domain):
                    results['risky'].append({
                        'email': email,
                        'reason': 'Disposable email provider'
                    })
                elif self.is_role_email(email):
                    results['risky'].append({
                        'email': email,
                        'reason': 'Role-based email address'
                    })
                else:
                    results['valid'].append(email)
            else:
                results['invalid'].append({
                    'email': email,
                    'reason': 'No MX record found'
                })
        
        except Exception:
            results['unknown'].append({
                'email': email,
                'reason': 'Domain verification failed'
            })
    
    return results

def is_disposable_email(self, domain: str) -> bool:
    """Check if domain is a disposable email provider"""
    disposable_domains = {
        '10minutemail.com', 'tempmail.org', 'guerrillamail.com',
        'mailinator.com', 'yopmail.com', 'trash-mail.com'
    }
    return domain in disposable_domains

def is_role_email(self, email: str) -> bool:
    """Check if email is a role-based address"""
    role_prefixes = {
        'admin', 'administrator', 'support', 'help', 'info',
        'sales', 'marketing', 'noreply', 'no-reply', 'postmaster'
    }
    local_part = email.split('@')[0]
    return local_part in role_prefixes
```

## Usage Examples

### 1. Quick Start Example
```python title="automatedemailsender.py" showLineNumbers{1}
# Basic email sending example
def quick_start_example():
    """Quick start example for sending emails"""
    
    # Initialize system
    db = EmailDatabase()
    sender = EmailSender(db)
    
    # Add email account
    account_id = db.add_email_account(
        name="My Gmail Account",
        email="your.email@gmail.com",
        smtp_server="smtp.gmail.com",
        smtp_port=587
    )
    
    # Create email template
    template_id = db.add_template(
        name="Welcome Email",
        subject="Welcome {first_name}!",
        body="""
        Hello {first_name},
        
        Welcome to our platform! We're excited to have you.
        
        Best regards,
        The Team
        """,
        variables=["first_name"]
    )
    
    # Add contacts
    contacts = [
        {"first_name": "John", "email": "john@example.com"},
        {"first_name": "Jane", "email": "jane@example.com"}
    ]
    
    for contact in contacts:
        db.add_contact(
            name=contact["first_name"],
            email=contact["email"],
            custom_fields=contact
        )
    
    # Send emails
    account = db.get_email_account(account_id)
    template = db.get_template(template_id)
    recipients = db.get_contacts()
    
    password = input("Enter email password: ")
    results = sender.send_bulk_emails(account, password, recipients, template)
    
    print(f"Sent: {results['sent']}, Failed: {results['failed']}")
```

### 2. Advanced Campaign Example
```python title="automatedemailsender.py" showLineNumbers{1}
def advanced_campaign_example():
    """Advanced email campaign with segmentation and scheduling"""
    
    db = EmailDatabase()
    sender = EmailSender(db)
    scheduler = EmailScheduler(sender)
    
    # Import contacts from CSV
    contacts = sender.parse_csv_contacts('customer_list.csv')
    
    # Segment contacts
    premium_customers = db.segment_contacts({
        'has_custom_field': ('subscription_type', 'premium')
    })
    
    new_customers = db.segment_contacts({
        'last_contacted_days': 30
    })
    
    # Create targeted templates
    premium_template = EmailTemplate(
        name="Premium Newsletter",
        subject="Exclusive Updates for Premium Members",
        body="Premium content for {first_name}...",
        is_html=True
    )
    
    # Schedule campaigns
    scheduler.schedule_email(
        account_id=1,
        template_id=premium_template.id,
        recipient_group="premium",
        schedule_time="2025-09-05T09:00:00",
        repeat_type="weekly"
    )
    
    # Start scheduler
    scheduler.start_scheduler()
```

## Troubleshooting Guide

### Common Issues and Solutions

**1. SMTP Authentication Errors**
```python title="automatedemailsender.py" showLineNumbers{1}
# Solution: Handle authentication properly
def handle_smtp_auth_error(self, error):
    """Handle SMTP authentication errors"""
    error_solutions = {
        '535': "Invalid credentials - check email/password",
        '534': "Authentication mechanism not supported",
        '587': "Enable 'Less secure app access' for Gmail",
        '465': "Try using TLS on port 587 instead of SSL on 465"
    }
    
    error_code = str(error).split()[0]
    solution = error_solutions.get(error_code, "Check SMTP settings and credentials")
    
    return f"Authentication Error: {solution}"
```

**2. Rate Limiting Issues**
```python title="automatedemailsender.py" showLineNumbers{1}
# Solution: Implement intelligent rate limiting
def implement_rate_limiting(self, provider: str):
    """Provider-specific rate limiting"""
    rate_limits = {
        'gmail.com': {'emails_per_minute': 20, 'emails_per_day': 500},
        'outlook.com': {'emails_per_minute': 30, 'emails_per_day': 300},
        'yahoo.com': {'emails_per_minute': 25, 'emails_per_day': 400}
    }
    
    return rate_limits.get(provider, {'emails_per_minute': 10, 'emails_per_day': 100})
```

**3. Large Attachment Handling**
```python title="automatedemailsender.py" showLineNumbers{1}
# Solution: Compress or split large attachments
def handle_large_attachments(self, attachments: List[str], max_size_mb: int = 25):
    """Handle large email attachments"""
    import zipfile
    
    total_size = sum(os.path.getsize(f) for f in attachments)
    max_size_bytes = max_size_mb * 1024 * 1024
    
    if total_size > max_size_bytes:
        # Create compressed archive
        zip_path = 'attachments.zip'
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for file_path in attachments:
                zipf.write(file_path, os.path.basename(file_path))
        
        return [zip_path] if os.path.getsize(zip_path) <= max_size_bytes else []
    
    return attachments
```

## Performance Optimization

### 1. Database Optimization
```python title="automatedemailsender.py" showLineNumbers{1}
def optimize_database(self):
    """Optimize database for better performance"""
    with sqlite3.connect(self.db_path) as conn:
        # Create indexes for better query performance
        conn.execute("CREATE INDEX IF NOT EXISTS idx_contacts_email ON contacts(email)")
        conn.execute("CREATE INDEX IF NOT EXISTS idx_email_history_sent_at ON email_history(sent_at)")
        conn.execute("CREATE INDEX IF NOT EXISTS idx_email_history_success ON email_history(success)")
        
        # Vacuum database to reclaim space
        conn.execute("VACUUM")
        
        # Analyze tables for query optimization
        conn.execute("ANALYZE")
```

### 2. Memory Management
```python title="automatedemailsender.py" showLineNumbers{1}
def process_large_recipient_list(self, recipients: List[Dict], batch_size: int = 100):
    """Process large recipient lists in batches"""
    for i in range(0, len(recipients), batch_size):
        batch = recipients[i:i + batch_size]
        yield batch
        
        # Optional: Add delay between batches
        time.sleep(1)
```

## Security Features

### 1. Password Encryption
```python title="automatedemailsender.py" showLineNumbers{1}
import cryptography.fernet as fernet
import base64

def encrypt_password(self, password: str, key: bytes = None) -> Tuple[str, bytes]:
    """Encrypt password for secure storage"""
    if key is None:
        key = fernet.Fernet.generate_key()
    
    f = fernet.Fernet(key)
    encrypted_password = f.encrypt(password.encode())
    return base64.b64encode(encrypted_password).decode(), key

def decrypt_password(self, encrypted_password: str, key: bytes) -> str:
    """Decrypt stored password"""
    f = fernet.Fernet(key)
    encrypted_bytes = base64.b64decode(encrypted_password.encode())
    return f.decrypt(encrypted_bytes).decode()
```

### 2. Input Sanitization
```python title="automatedemailsender.py" showLineNumbers{1}
def sanitize_email_content(self, content: str) -> str:
    """Sanitize email content to prevent injection attacks"""
    import html
    import re
    
    # Escape HTML characters
    content = html.escape(content)
    
    # Remove potentially dangerous patterns
    dangerous_patterns = [
        r'<script.*?</script>',
        r'javascript:',
        r'vbscript:',
        r'onload=',
        r'onerror='
    ]
    
    for pattern in dangerous_patterns:
        content = re.sub(pattern, '', content, flags=re.IGNORECASE)
    
    return content
```

## Next Steps and Extensions

### Recommended Improvements

1. **Web Interface**: Create a Flask/Django web interface
2. **API Integration**: Add REST API for external integrations
3. **Mobile App**: Build companion mobile application
4. **Cloud Storage**: Integrate with cloud storage for attachments
5. **Advanced Analytics**: Add click tracking and engagement metrics
6. **Machine Learning**: Implement send-time optimization
7. **Multi-language**: Add internationalization support
8. **Enterprise Features**: Add SSO, audit logs, and compliance features

### Sample Projects to Build

1. **Newsletter Platform**: Build a complete newsletter service
2. **E-commerce Notifications**: Create transactional email system
3. **CRM Integration**: Integrate with customer relationship management
4. **Marketing Automation**: Build automated drip campaigns
5. **Event Notifications**: Create event-driven email triggers

This comprehensive email automation system provides enterprise-level capabilities for managing email campaigns, contact lists, and analytics. The modular design allows for easy customization and extension based on specific requirements. ðŸ“§ðŸš€
