---
title: Hangman Game with Database Integration
description: An advanced hangman game with SQLite database integration, user authentication, statistics tracking, multiple difficulty levels, and comprehensive GUI. Features player accounts, word management, leaderboards, and detailed game analytics.
sidebar: 
    order: 59
hero:
    actions:
        - text: View Source Code
          link: https://github.com/Ravikisha/PythonCentralHub/blob/main/projects/intermediate/hangmandatabase.py
          icon: external
          variant: primary
---
import FileCode from '../../../../components/FileCode.astro'

## Abstract

Create a comprehensive hangman game with database integration that includes user authentication, statistics tracking, word management, and advanced gameplay features. This project demonstrates database operations, user session management, game state persistence, and building feature-rich gaming applications.

## Prerequisites

- Python 3.7 or above
- Text Editor or IDE
- Solid understanding of Python syntax and OOP concepts
- Knowledge of SQLite database operations
- Familiarity with GUI development using Tkinter
- Understanding of user authentication and session management
- Basic knowledge of game development principles

## Getting Started

### Create a new project
1. Create a new project folder and name it `hangmanDatabase`.
2. Create a new file and name it `hangmandatabase.py`.
3. Install required dependencies: `pip install tkinter sqlite3`
4. Open the project folder in your favorite text editor or IDE.
5. Copy the code below and paste it into your `hangmandatabase.py` file.

### Write the code
1. Add the following code to your `hangmandatabase.py` file.
<FileCode file="projects/intermediate/hangmandatabase.py" lang="python" title="Hangman Game with Database Integration" />
2. Save the file.
3. Run the following command to run the application.
```cmd title="command" showLineNumbers{1}
C:\Users\username\Documents\hangmanDatabase> python hangmandatabase.py
Hangman Game Database
====================
✓ Database initialized
✓ Default words loaded
✓ User authentication ready
✓ Statistics tracking enabled
Welcome to Advanced Hangman!
Please login or create account...
```

## Explanation

1. The `HangmanDatabase` class manages SQLite database operations for users, words, and game history.
2. The `HangmanGame` class handles game logic, state management, and scoring system.
3. The `HangmanGUI` class provides a comprehensive Tkinter interface with multiple tabs.
4. User authentication system with password hashing for security.
5. Word management with categories, difficulty levels, and hints.
6. Statistics tracking including games played, win rate, and performance metrics.
7. Leaderboard system with ranking based on various criteria.
8. Game state persistence allowing resume functionality.
9. Multiple difficulty levels affecting word selection and scoring.
10. Comprehensive admin panel for word and user management.
11. Visual hangman drawing with ASCII art progression.
12. Detailed analytics and reporting for player performance.

## Next Steps

Congratulations! You have successfully created a Hangman Game with Database in Python. Experiment with the code and see if you can modify the application. Here are a few suggestions:
- Add multiplayer functionality with turn-based gameplay
- Implement themed word categories (animals, countries, movies)
- Create achievement system with badges and rewards
- Add sound effects and background music
- Implement word definition display using dictionary API
- Create tournament mode with bracket-style competitions
- Add social features like friend lists and challenges
- Implement word contribution system for community words
- Create mobile-responsive web version using Flask

## Conclusion

In this project, you learned how to create a Hangman Game with Database in Python using advanced game development concepts. You also learned about database integration, user authentication, statistics tracking, and implementing comprehensive gaming systems with persistent data storage. You can find the source code on [GitHub](https://github.com/Ravikisha/PythonCentralHub/blob/main/projects/intermediate/hangmandatabase.py)

## How It Works

### 1. Database Schema Design
```python title="hangmandatabase.py" showLineNumbers{1}
class HangmanDatabase:
    def init_database(self):
        with sqlite3.connect(self.db_path) as conn:
            # Users table
            conn.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username TEXT UNIQUE NOT NULL,
                    password_hash TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    last_login TIMESTAMP
                )
            ''')
            
            # Words table
            conn.execute('''
                CREATE TABLE IF NOT EXISTS words (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    word TEXT NOT NULL,
                    category TEXT NOT NULL,
                    difficulty INTEGER NOT NULL,
                    hint TEXT,
                    added_by INTEGER,
                    FOREIGN KEY (added_by) REFERENCES users (id)
                )
            ''')
```

The database structure includes:
- **User Management**: Account creation, authentication, and session tracking
- **Word Library**: Categorized words with difficulty ratings and hints
- **Game History**: Complete record of all games played
- **Statistics**: Aggregated player performance metrics
- **Leaderboards**: Ranking system for competitive play

### 2. Authentication System
```python title="hangmandatabase.py" showLineNumbers{1}
def create_player(self, username: str, password: str) -> bool:
    password_hash = hashlib.sha256(password.encode()).hexdigest()
    
    with sqlite3.connect(self.db_path) as conn:
        try:
            conn.execute(
                "INSERT INTO users (username, password_hash) VALUES (?, ?)",
                (username, password_hash)
            )
            return True
        except sqlite3.IntegrityError:
            return False

def authenticate_player(self, username: str, password: str) -> Optional[Dict]:
    password_hash = hashlib.sha256(password.encode()).hexdigest()
    
    with sqlite3.connect(self.db_path) as conn:
        cursor = conn.execute(
            "SELECT id, username FROM users WHERE username = ? AND password_hash = ?",
            (username, password_hash)
        )
        user = cursor.fetchone()
        return dict(zip([col[0] for col in cursor.description], user)) if user else None
```

### 3. Game Logic Implementation
```python title="hangmandatabase.py" showLineNumbers{1}
class HangmanGame:
    def make_guess(self, letter: str) -> Dict:
        letter = letter.upper()
        
        if self.game_over:
            return {"status": "error", "message": "Game is over"}
        
        if letter in self.guessed_letters:
            return {"status": "error", "message": "Letter already guessed"}
        
        if not letter.isalpha() or len(letter) != 1:
            return {"status": "error", "message": "Please enter a single letter"}
        
        self.guessed_letters.append(letter)
        
        if letter in self.current_word:
            correct_positions = [i for i, char in enumerate(self.current_word) if char == letter]
            
            if self.is_word_complete():
                self.game_won = True
                self.game_over = True
                self.end_time = datetime.datetime.now()
                return {
                    "status": "won",
                    "message": f"Congratulations! You won! The word was: {self.current_word}",
                    "letter": letter,
                    "positions": correct_positions
                }
```

### 4. Statistics and Analytics
```python title="hangmandatabase.py" showLineNumbers{1}
def get_player_stats(self, player_id: int) -> Dict:
    with sqlite3.connect(self.db_path) as conn:
        # Basic stats
        cursor = conn.execute(
            "SELECT COUNT(*) as total_games, AVG(CASE WHEN won THEN 1.0 ELSE 0.0 END) as win_rate "
            "FROM game_history WHERE player_id = ?",
            (player_id,)
        )
        basic_stats = cursor.fetchone()
        
        # Category performance
        cursor = conn.execute("""
            SELECT w.category, COUNT(*) as games, 
                   AVG(CASE WHEN gh.won THEN 1.0 ELSE 0.0 END) as win_rate
            FROM game_history gh
            JOIN words w ON gh.word_id = w.id
            WHERE gh.player_id = ?
            GROUP BY w.category
        """, (player_id,))
        category_stats = cursor.fetchall()
```

### 5. GUI Implementation
```python title="hangmandatabase.py" showLineNumbers{1}
class HangmanGUI:
    def setup_ui(self):
        # Create notebook for tabs
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Game tab
        self.game_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.game_frame, text="Game")
        self.setup_game_tab()
        
        # Statistics tab
        self.stats_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.stats_frame, text="Statistics")
        self.setup_stats_tab()
        
        # Leaderboard tab
        self.leaderboard_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.leaderboard_frame, text="Leaderboard")
        self.setup_leaderboard_tab()
```

### 6. Hangman Visual Display
```python title="hangmandatabase.py" showLineNumbers{1}
def get_hangman_display(self) -> str:
    hangman_stages = [
        """
   +---+
   |   |
       |
       |
       |
       |
=========
""",
        """
   +---+
   |   |
   O   |
       |
       |
       |
=========
""",
        """
   +---+
   |   |
   O   |
   |   |
       |
       |
=========
""",
        """
   +---+
   |   |
   O   |
  /|   |
       |
       |
=========
""",
        """
   +---+
   |   |
   O   |
  /|\\  |
       |
       |
=========
""",
        """
   +---+
   |   |
   O   |
  /|\\  |
  /    |
       |
=========
""",
        """
   +---+
   |   |
   O   |
  /|\\  |
  / \\  |
       |
=========
"""
    ]
    return hangman_stages[self.wrong_guesses]
```

## Advanced Game Features

### 1. Multiplayer Tournament System
```python title="hangmandatabase.py" showLineNumbers{1}
class TournamentManager:
    def __init__(self, database: HangmanDatabase):
        self.db = database
        self.active_tournaments = {}
    
    def create_tournament(self, name: str, max_players: int = 8, 
                         rounds: int = 3, time_limit: int = 300) -> int:
        """Create a new tournament"""
        with sqlite3.connect(self.db.db_path) as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS tournaments (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    max_players INTEGER NOT NULL,
                    rounds INTEGER NOT NULL,
                    time_limit INTEGER NOT NULL,
                    status TEXT DEFAULT 'waiting',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    started_at TIMESTAMP,
                    completed_at TIMESTAMP
                )
            ''')
            
            conn.execute('''
                CREATE TABLE IF NOT EXISTS tournament_participants (
                    tournament_id INTEGER,
                    player_id INTEGER,
                    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    eliminated_round INTEGER,
                    final_rank INTEGER,
                    FOREIGN KEY (tournament_id) REFERENCES tournaments (id),
                    FOREIGN KEY (player_id) REFERENCES users (id)
                )
            ''')
            
            cursor = conn.execute(
                "INSERT INTO tournaments (name, max_players, rounds, time_limit) VALUES (?, ?, ?, ?)",
                (name, max_players, rounds, time_limit)
            )
            tournament_id = cursor.lastrowid
            
            self.active_tournaments[tournament_id] = {
                'name': name,
                'max_players': max_players,
                'participants': [],
                'current_round': 0,
                'status': 'waiting'
            }
            
            return tournament_id
    
    def join_tournament(self, tournament_id: int, player_id: int) -> bool:
        """Join a tournament"""
        tournament = self.active_tournaments.get(tournament_id)
        if not tournament or tournament['status'] != 'waiting':
            return False
        
        if len(tournament['participants']) >= tournament['max_players']:
            return False
        
        with sqlite3.connect(self.db.db_path) as conn:
            conn.execute(
                "INSERT INTO tournament_participants (tournament_id, player_id) VALUES (?, ?)",
                (tournament_id, player_id)
            )
        
        tournament['participants'].append(player_id)
        
        # Start tournament if full
        if len(tournament['participants']) == tournament['max_players']:
            self.start_tournament(tournament_id)
        
        return True
    
    def start_tournament(self, tournament_id: int):
        """Start tournament when ready"""
        tournament = self.active_tournaments[tournament_id]
        tournament['status'] = 'active'
        tournament['current_round'] = 1
        
        with sqlite3.connect(self.db.db_path) as conn:
            conn.execute(
                "UPDATE tournaments SET status = 'active', started_at = datetime('now') WHERE id = ?",
                (tournament_id,)
            )
        
        # Initialize first round
        self.create_tournament_round(tournament_id, 1)
    
    def create_tournament_round(self, tournament_id: int, round_number: int):
        """Create games for tournament round"""
        tournament = self.active_tournaments[tournament_id]
        participants = tournament['participants']
        
        # Create matchups (for now, all players play same word)
        word_data = self.db.get_random_word(difficulty=round_number)
        
        for player_id in participants:
            # Create game record
            with sqlite3.connect(self.db.db_path) as conn:
                conn.execute('''
                    INSERT INTO tournament_games 
                    (tournament_id, round_number, player_id, word_id, status)
                    VALUES (?, ?, ?, ?, 'pending')
                ''', (tournament_id, round_number, player_id, word_data['id']))
```

### 2. Achievement System
```python title="hangmandatabase.py" showLineNumbers{1}
class AchievementSystem:
    def __init__(self, database: HangmanDatabase):
        self.db = database
        self.achievements = self.load_achievements()
    
    def load_achievements(self) -> Dict:
        """Load achievement definitions"""
        return {
            'first_win': {
                'name': 'First Victory',
                'description': 'Win your first game',
                'icon': '🎉',
                'points': 10
            },
            'perfect_game': {
                'name': 'Perfect Game',
                'description': 'Win without any wrong guesses',
                'icon': '⭐',
                'points': 50
            },
            'speed_demon': {
                'name': 'Speed Demon',
                'description': 'Complete a game in under 30 seconds',
                'icon': '⚡',
                'points': 30
            },
            'word_master': {
                'name': 'Word Master',
                'description': 'Win 100 games',
                'icon': '👑',
                'points': 100
            },
            'streak_master': {
                'name': 'Streak Master',
                'description': 'Win 10 games in a row',
                'icon': '🔥',
                'points': 75
            },
            'category_expert': {
                'name': 'Category Expert',
                'description': 'Win 20 games in a single category',
                'icon': '🎯',
                'points': 40
            },
            'hint_free': {
                'name': 'Hint Free',
                'description': 'Win 5 games without using hints',
                'icon': '🧠',
                'points': 25
            }
        }
    
    def check_achievements(self, player_id: int, game_result: Dict):
        """Check and award achievements"""
        new_achievements = []
        
        # Get player stats
        stats = self.db.get_player_stats(player_id)
        
        # Check each achievement
        for achievement_id, achievement in self.achievements.items():
            if self.has_achievement(player_id, achievement_id):
                continue  # Already earned
            
            if self.check_achievement_condition(achievement_id, stats, game_result):
                self.award_achievement(player_id, achievement_id)
                new_achievements.append(achievement)
        
        return new_achievements
    
    def check_achievement_condition(self, achievement_id: str, stats: Dict, game_result: Dict) -> bool:
        """Check if achievement condition is met"""
        if achievement_id == 'first_win':
            return stats['total_games_won'] == 1
        
        elif achievement_id == 'perfect_game':
            return game_result['won'] and game_result['wrong_guesses'] == 0
        
        elif achievement_id == 'speed_demon':
            return game_result['won'] and game_result['duration'] < 30
        
        elif achievement_id == 'word_master':
            return stats['total_games_won'] >= 100
        
        elif achievement_id == 'streak_master':
            return stats.get('current_win_streak', 0) >= 10
        
        elif achievement_id == 'category_expert':
            # Check if won 20+ games in any single category
            for category_stat in stats.get('category_performance', []):
                if category_stat['games_won'] >= 20:
                    return True
        
        elif achievement_id == 'hint_free':
            # Check last 5 games for hint usage
            return self.check_recent_hint_free_games(stats['player_id'], 5)
        
        return False
    
    def award_achievement(self, player_id: int, achievement_id: str):
        """Award achievement to player"""
        with sqlite3.connect(self.db.db_path) as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS player_achievements (
                    player_id INTEGER,
                    achievement_id TEXT,
                    earned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (player_id) REFERENCES users (id)
                )
            ''')
            
            conn.execute(
                "INSERT INTO player_achievements (player_id, achievement_id) VALUES (?, ?)",
                (player_id, achievement_id)
            )
            
            # Award points
            achievement = self.achievements[achievement_id]
            conn.execute(
                "UPDATE users SET achievement_points = achievement_points + ? WHERE id = ?",
                (achievement['points'], player_id)
            )
```

### 3. Advanced Word Management
```python title="hangmandatabase.py" showLineNumbers{1}
def import_word_list(self, file_path: str, category: str = "imported") -> Dict:
    """Import words from external file"""
    results = {'imported': 0, 'skipped': 0, 'errors': []}
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip().upper()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse line (word, difficulty, hint)
                parts = line.split('|')
                word = parts[0].strip()
                difficulty = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else 2
                hint = parts[2].strip() if len(parts) > 2 else ""
                
                # Validate word
                if not word.isalpha() or len(word) < 3:
                    results['errors'].append(f"Line {line_num}: Invalid word '{word}'")
                    continue
                
                # Check if word exists
                if self.word_exists(word):
                    results['skipped'] += 1
                    continue
                
                # Add word
                if self.add_word(word, category, difficulty, hint):
                    results['imported'] += 1
                else:
                    results['errors'].append(f"Line {line_num}: Failed to add word '{word}'")
    
    except Exception as e:
        results['errors'].append(f"File error: {str(e)}")
    
    return results

def get_word_suggestions(self, partial_word: str, category: str = None) -> List[str]:
    """Get word suggestions based on partial input"""
    with sqlite3.connect(self.db_path) as conn:
        query = "SELECT word FROM words WHERE word LIKE ?"
        params = [f"{partial_word}%"]
        
        if category:
            query += " AND category = ?"
            params.append(category)
        
        query += " ORDER BY LENGTH(word), word LIMIT 10"
        
        cursor = conn.execute(query, params)
        return [row[0] for row in cursor.fetchall()]

def analyze_word_difficulty(self, word: str) -> Dict:
    """Analyze word characteristics to suggest difficulty"""
    analysis = {
        'length': len(word),
        'unique_letters': len(set(word)),
        'vowel_count': sum(1 for char in word if char in 'AEIOU'),
        'consonant_clusters': 0,
        'common_letters': 0,
        'suggested_difficulty': 2
    }
    
    # Common letters in English
    common_letters = 'ETAOINSHRDLCUMWFGYPBVKJXQZ'
    analysis['common_letters'] = sum(1 for char in word if char in common_letters[:12])
    
    # Count consonant clusters
    consonants = 'BCDFGHJKLMNPQRSTVWXYZ'
    cluster_count = 0
    for i in range(len(word) - 1):
        if word[i] in consonants and word[i + 1] in consonants:
            cluster_count += 1
    analysis['consonant_clusters'] = cluster_count
    
    # Suggest difficulty based on characteristics
    difficulty_score = 0
    
    if analysis['length'] > 8:
        difficulty_score += 1
    if analysis['unique_letters'] / analysis['length'] > 0.8:
        difficulty_score += 1
    if analysis['consonant_clusters'] > 2:
        difficulty_score += 1
    if analysis['common_letters'] < 3:
        difficulty_score += 1
    
    analysis['suggested_difficulty'] = min(max(1, 2 + difficulty_score), 5)
    
    return analysis
```

### 4. Game Variations and Modes
```python title="hangmandatabase.py" showLineNumbers{1}
class GameModeManager:
    def __init__(self, database: HangmanDatabase):
        self.db = database
        self.game_modes = self.initialize_game_modes()
    
    def initialize_game_modes(self) -> Dict:
        """Initialize different game modes"""
        return {
            'classic': {
                'name': 'Classic Hangman',
                'description': 'Traditional hangman game',
                'max_wrong_guesses': 6,
                'hints_allowed': True,
                'time_limit': None,
                'scoring_multiplier': 1.0
            },
            'speed': {
                'name': 'Speed Mode',
                'description': 'Fast-paced with time limit',
                'max_wrong_guesses': 6,
                'hints_allowed': False,
                'time_limit': 60,
                'scoring_multiplier': 1.5
            },
            'hardcore': {
                'name': 'Hardcore',
                'description': 'No hints, fewer guesses',
                'max_wrong_guesses': 4,
                'hints_allowed': False,
                'time_limit': None,
                'scoring_multiplier': 2.0
            },
            'zen': {
                'name': 'Zen Mode',
                'description': 'Unlimited guesses, no pressure',
                'max_wrong_guesses': 999,
                'hints_allowed': True,
                'time_limit': None,
                'scoring_multiplier': 0.5
            },
            'challenge': {
                'name': 'Daily Challenge',
                'description': 'Special daily word with bonus points',
                'max_wrong_guesses': 6,
                'hints_allowed': True,
                'time_limit': None,
                'scoring_multiplier': 3.0
            }
        }
    
    def create_game_with_mode(self, player_id: int, mode: str, category: str = None) -> 'HangmanGame':
        """Create game instance with specific mode"""
        if mode not in self.game_modes:
            raise ValueError(f"Unknown game mode: {mode}")
        
        mode_config = self.game_modes[mode]
        
        # Get appropriate word based on mode
        if mode == 'challenge':
            word_data = self.get_daily_challenge_word()
        else:
            difficulty = self.get_player_appropriate_difficulty(player_id)
            word_data = self.db.get_random_word(category, difficulty)
        
        # Create custom game instance
        game = HangmanGame(self.db)
        game.mode = mode
        game.mode_config = mode_config
        game.max_wrong_guesses = mode_config['max_wrong_guesses']
        game.hints_allowed = mode_config['hints_allowed']
        game.time_limit = mode_config['time_limit']
        game.scoring_multiplier = mode_config['scoring_multiplier']
        
        if word_data:
            game.current_word = word_data['word']
            game.current_word_data = word_data
            game.start_time = datetime.datetime.now()
            
            if game.time_limit:
                game.end_time = game.start_time + datetime.timedelta(seconds=game.time_limit)
        
        return game
    
    def get_daily_challenge_word(self) -> Dict:
        """Get today's daily challenge word"""
        today = datetime.date.today()
        
        with sqlite3.connect(self.db.db_path) as conn:
            # Check if today's challenge exists
            cursor = conn.execute(
                "SELECT * FROM daily_challenges WHERE date = ?",
                (today.isoformat(),)
            )
            challenge = cursor.fetchone()
            
            if challenge:
                # Return existing challenge
                cursor = conn.execute(
                    "SELECT * FROM words WHERE id = ?",
                    (challenge[2],)  # word_id
                )
                return dict(zip([col[0] for col in cursor.description], cursor.fetchone()))
            else:
                # Create new daily challenge
                word_data = self.db.get_random_word(difficulty=3)  # Medium difficulty
                
                conn.execute(
                    "INSERT INTO daily_challenges (date, word_id) VALUES (?, ?)",
                    (today.isoformat(), word_data['id'])
                )
                
                return word_data
```

### 5. Enhanced Statistics and Analytics
```python title="hangmandatabase.py" showLineNumbers{1}
def get_comprehensive_analytics(self, player_id: int) -> Dict:
    """Get comprehensive player analytics"""
    with sqlite3.connect(self.db_path) as conn:
        analytics = {}
        
        # Performance over time
        cursor = conn.execute("""
            SELECT date(created_at) as game_date,
                   COUNT(*) as games_played,
                   COUNT(CASE WHEN won THEN 1 END) as games_won,
                   AVG(duration) as avg_duration,
                   AVG(wrong_guesses) as avg_wrong_guesses
            FROM game_history 
            WHERE player_id = ? AND created_at >= date('now', '-30 days')
            GROUP BY date(created_at)
            ORDER BY game_date
        """, (player_id,))
        
        analytics['daily_performance'] = [
            {
                'date': row[0],
                'games_played': row[1],
                'games_won': row[2],
                'win_rate': (row[2] / row[1] * 100) if row[1] > 0 else 0,
                'avg_duration': row[3] or 0,
                'avg_wrong_guesses': row[4] or 0
            }
            for row in cursor.fetchall()
        ]
        
        # Difficulty progression
        cursor = conn.execute("""
            SELECT w.difficulty,
                   COUNT(*) as games_played,
                   COUNT(CASE WHEN gh.won THEN 1 END) as games_won,
                   AVG(gh.duration) as avg_duration
            FROM game_history gh
            JOIN words w ON gh.word_id = w.id
            WHERE gh.player_id = ?
            GROUP BY w.difficulty
            ORDER BY w.difficulty
        """, (player_id,))
        
        analytics['difficulty_performance'] = [
            {
                'difficulty': row[0],
                'games_played': row[1],
                'games_won': row[2],
                'win_rate': (row[2] / row[1] * 100) if row[1] > 0 else 0,
                'avg_duration': row[3] or 0
            }
            for row in cursor.fetchall()
        ]
        
        # Letter accuracy
        cursor = conn.execute("""
            SELECT guessed_letters, wrong_guesses
            FROM game_history 
            WHERE player_id = ? AND guessed_letters IS NOT NULL
        """, (player_id,))
        
        letter_stats = {}
        for row in cursor.fetchall():
            letters = eval(row[0]) if row[0] else []
            wrong_count = row[1]
            
            # This is simplified - in real implementation, track correct vs wrong letters
            for letter in letters:
                if letter not in letter_stats:
                    letter_stats[letter] = {'used': 0, 'success_rate': 0}
                letter_stats[letter]['used'] += 1
        
        analytics['letter_usage'] = letter_stats
        
        # Streak analysis
        cursor = conn.execute("""
            SELECT won, created_at
            FROM game_history 
            WHERE player_id = ?
            ORDER BY created_at DESC
            LIMIT 50
        """, (player_id,))
        
        games = cursor.fetchall()
        current_streak = 0
        max_streak = 0
        temp_streak = 0
        
        for game in games:
            if game[0]:  # Won
                temp_streak += 1
                max_streak = max(max_streak, temp_streak)
                if current_streak == 0:  # First win in sequence
                    current_streak = temp_streak
            else:  # Lost
                temp_streak = 0
        
        analytics['streaks'] = {
            'current_win_streak': current_streak,
            'best_win_streak': max_streak
        }
        
        # Time-based patterns
        cursor = conn.execute("""
            SELECT strftime('%H', created_at) as hour,
                   COUNT(*) as games_played,
                   COUNT(CASE WHEN won THEN 1 END) as games_won
            FROM game_history 
            WHERE player_id = ?
            GROUP BY strftime('%H', created_at)
            ORDER BY hour
        """, (player_id,))
        
        analytics['hourly_performance'] = [
            {
                'hour': int(row[0]),
                'games_played': row[1],
                'games_won': row[2],
                'win_rate': (row[2] / row[1] * 100) if row[1] > 0 else 0
            }
            for row in cursor.fetchall()
        ]
        
        return analytics

def generate_progress_report(self, player_id: int) -> str:
    """Generate detailed progress report"""
    analytics = self.get_comprehensive_analytics(player_id)
    stats = self.get_player_stats(player_id)
    
    report = f"""
=== HANGMAN PROGRESS REPORT ===

Player Statistics:
- Total Games: {stats['total_games']}
- Games Won: {stats['total_games_won']}
- Win Rate: {stats['win_rate']:.1f}%
- Average Duration: {stats['avg_duration']:.1f} seconds
- Current Streak: {analytics['streaks']['current_win_streak']}
- Best Streak: {analytics['streaks']['best_win_streak']}

Difficulty Breakdown:
"""
    
    for diff_stat in analytics['difficulty_performance']:
        report += f"- Level {diff_stat['difficulty']}: {diff_stat['win_rate']:.1f}% win rate ({diff_stat['games_won']}/{diff_stat['games_played']})\n"
    
    report += f"""
Recent Performance (Last 7 Days):
"""
    recent_games = analytics['daily_performance'][-7:]
    total_recent = sum(day['games_played'] for day in recent_games)
    won_recent = sum(day['games_won'] for day in recent_games)
    
    report += f"- Games Played: {total_recent}\n"
    report += f"- Games Won: {won_recent}\n"
    report += f"- Recent Win Rate: {(won_recent/total_recent*100) if total_recent > 0 else 0:.1f}%\n"
    
    report += "\n=== END REPORT ===\n"
    
    return report
```

### 6. Social Features and Leaderboards
```python title="hangmandatabase.py" showLineNumbers{1}
class SocialFeatures:
    def __init__(self, database: HangmanDatabase):
        self.db = database
        self.setup_social_tables()
    
    def setup_social_tables(self):
        """Setup social feature tables"""
        with sqlite3.connect(self.db.db_path) as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS friendships (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    player1_id INTEGER,
                    player2_id INTEGER,
                    status TEXT DEFAULT 'pending',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (player1_id) REFERENCES users (id),
                    FOREIGN KEY (player2_id) REFERENCES users (id)
                )
            ''')
            
            conn.execute('''
                CREATE TABLE IF NOT EXISTS challenges (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    challenger_id INTEGER,
                    challenged_id INTEGER,
                    word_id INTEGER,
                    challenger_score INTEGER,
                    challenged_score INTEGER,
                    status TEXT DEFAULT 'pending',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    completed_at TIMESTAMP,
                    FOREIGN KEY (challenger_id) REFERENCES users (id),
                    FOREIGN KEY (challenged_id) REFERENCES users (id),
                    FOREIGN KEY (word_id) REFERENCES words (id)
                )
            ''')
    
    def send_friend_request(self, sender_id: int, recipient_username: str) -> bool:
        """Send friend request"""
        with sqlite3.connect(self.db.db_path) as conn:
            # Get recipient ID
            cursor = conn.execute(
                "SELECT id FROM users WHERE username = ?",
                (recipient_username,)
            )
            recipient = cursor.fetchone()
            
            if not recipient:
                return False
            
            recipient_id = recipient[0]
            
            # Check if friendship already exists
            cursor = conn.execute("""
                SELECT id FROM friendships 
                WHERE (player1_id = ? AND player2_id = ?) 
                   OR (player1_id = ? AND player2_id = ?)
            """, (sender_id, recipient_id, recipient_id, sender_id))
            
            if cursor.fetchone():
                return False  # Friendship already exists
            
            # Create friend request
            conn.execute(
                "INSERT INTO friendships (player1_id, player2_id) VALUES (?, ?)",
                (sender_id, recipient_id)
            )
            
            return True
    
    def accept_friend_request(self, friendship_id: int) -> bool:
        """Accept friend request"""
        with sqlite3.connect(self.db.db_path) as conn:
            conn.execute(
                "UPDATE friendships SET status = 'accepted' WHERE id = ?",
                (friendship_id,)
            )
            return True
    
    def create_challenge(self, challenger_id: int, challenged_username: str, word_id: int) -> int:
        """Create a challenge between players"""
        with sqlite3.connect(self.db.db_path) as conn:
            # Get challenged player ID
            cursor = conn.execute(
                "SELECT id FROM users WHERE username = ?",
                (challenged_username,)
            )
            challenged = cursor.fetchone()
            
            if not challenged:
                return None
            
            challenged_id = challenged[0]
            
            # Create challenge
            cursor = conn.execute(
                "INSERT INTO challenges (challenger_id, challenged_id, word_id) VALUES (?, ?, ?)",
                (challenger_id, challenged_id, word_id)
            )
            
            return cursor.lastrowid
    
    def get_global_leaderboard(self, period: str = 'all_time', limit: int = 10) -> List[Dict]:
        """Get global leaderboard"""
        with sqlite3.connect(self.db.db_path) as conn:
            base_query = """
                SELECT u.username, u.achievement_points,
                       COUNT(gh.id) as total_games,
                       COUNT(CASE WHEN gh.won THEN 1 END) as games_won,
                       AVG(CASE WHEN gh.won THEN gh.duration END) as avg_win_time
                FROM users u
                LEFT JOIN game_history gh ON u.id = gh.player_id
            """
            
            if period == 'weekly':
                base_query += " WHERE gh.created_at >= date('now', '-7 days')"
            elif period == 'monthly':
                base_query += " WHERE gh.created_at >= date('now', '-30 days')"
            
            base_query += """
                GROUP BY u.id, u.username, u.achievement_points
                HAVING total_games > 0
                ORDER BY games_won DESC, avg_win_time ASC
                LIMIT ?
            """
            
            cursor = conn.execute(base_query, (limit,))
            
            leaderboard = []
            for i, row in enumerate(cursor.fetchall(), 1):
                leaderboard.append({
                    'rank': i,
                    'username': row[0],
                    'achievement_points': row[1],
                    'total_games': row[2],
                    'games_won': row[3],
                    'win_rate': (row[3] / row[2] * 100) if row[2] > 0 else 0,
                    'avg_win_time': row[4] or 0
                })
            
            return leaderboard
```

## Advanced GUI Enhancements

### 1. Modern Theme System
```python title="hangmandatabase.py" showLineNumbers{1}
def apply_theme(self, theme_name: str = 'default'):
    """Apply visual theme to GUI"""
    themes = {
        'default': {
            'bg_color': '#f0f0f0',
            'text_color': '#333333',
            'accent_color': '#4CAF50',
            'button_color': '#2196F3',
            'error_color': '#f44336'
        },
        'dark': {
            'bg_color': '#2b2b2b',
            'text_color': '#ffffff',
            'accent_color': '#81C784',
            'button_color': '#64B5F6',
            'error_color': '#e57373'
        },
        'ocean': {
            'bg_color': '#e1f5fe',
            'text_color': '#01579b',
            'accent_color': '#00bcd4',
            'button_color': '#0288d1',
            'error_color': '#f44336'
        }
    }
    
    if theme_name not in themes:
        theme_name = 'default'
    
    theme = themes[theme_name]
    
    # Apply theme to root window
    self.root.configure(bg=theme['bg_color'])
    
    # Apply to all frames and widgets
    self.apply_theme_to_widgets(self.root, theme)

def apply_theme_to_widgets(self, parent, theme):
    """Recursively apply theme to all widgets"""
    for child in parent.winfo_children():
        widget_class = child.winfo_class()
        
        if widget_class in ['Frame', 'Toplevel']:
            child.configure(bg=theme['bg_color'])
        elif widget_class == 'Label':
            child.configure(bg=theme['bg_color'], fg=theme['text_color'])
        elif widget_class == 'Button':
            child.configure(bg=theme['button_color'], fg='white')
        elif widget_class in ['Entry', 'Text']:
            child.configure(bg='white', fg=theme['text_color'])
        
        # Recursively apply to children
        self.apply_theme_to_widgets(child, theme)
```

### 2. Animation System
```python title="hangmandatabase.py" showLineNumbers{1}
def animate_hangman_drawing(self, stage: int):
    """Animate hangman drawing with smooth transitions"""
    if not hasattr(self, 'canvas'):
        return
    
    # Clear previous drawing
    self.canvas.delete("hangman")
    
    # Animate drawing each part
    parts = [
        self.draw_gallows,
        self.draw_head,
        self.draw_body,
        self.draw_left_arm,
        self.draw_right_arm,
        self.draw_left_leg,
        self.draw_right_leg
    ]
    
    for i in range(min(stage + 1, len(parts))):
        self.root.after(i * 200, lambda idx=i: parts[idx]())

def draw_gallows(self):
    """Draw gallows structure"""
    # Base
    self.canvas.create_line(20, 180, 120, 180, width=3, tags="hangman", fill="brown")
    # Pole
    self.canvas.create_line(40, 180, 40, 20, width=3, tags="hangman", fill="brown")
    # Top beam
    self.canvas.create_line(40, 20, 100, 20, width=3, tags="hangman", fill="brown")
    # Noose
    self.canvas.create_line(100, 20, 100, 40, width=2, tags="hangman", fill="black")

def draw_head(self):
    """Draw head with animation"""
    self.canvas.create_oval(85, 40, 115, 70, outline="black", width=2, tags="hangman")
    # Add face after a delay
    self.root.after(100, self.draw_face)

def draw_face(self):
    """Draw facial features"""
    # Eyes
    self.canvas.create_oval(92, 48, 96, 52, fill="black", tags="hangman")
    self.canvas.create_oval(104, 48, 108, 52, fill="black", tags="hangman")
    # Mouth (sad face)
    self.canvas.create_arc(95, 58, 105, 65, start=0, extent=180, outline="black", tags="hangman")
```

### 3. Sound Effects Integration
```python title="hangmandatabase.py" showLineNumbers{1}
import pygame
import os

class SoundManager:
    def __init__(self):
        try:
            pygame.mixer.init()
            self.sounds_enabled = True
            self.load_sounds()
        except:
            self.sounds_enabled = False
    
    def load_sounds(self):
        """Load game sound effects"""
        sound_dir = "sounds"
        self.sounds = {}
        
        sound_files = {
            'correct_letter': 'correct.wav',
            'wrong_letter': 'wrong.wav',
            'game_won': 'victory.wav',
            'game_lost': 'defeat.wav',
            'button_click': 'click.wav',
            'achievement': 'achievement.wav'
        }
        
        for sound_name, filename in sound_files.items():
            try:
                sound_path = os.path.join(sound_dir, filename)
                if os.path.exists(sound_path):
                    self.sounds[sound_name] = pygame.mixer.Sound(sound_path)
            except:
                pass
    
    def play_sound(self, sound_name: str):
        """Play sound effect"""
        if self.sounds_enabled and sound_name in self.sounds:
            try:
                self.sounds[sound_name].play()
            except:
                pass
    
    def set_volume(self, volume: float):
        """Set master volume (0.0 to 1.0)"""
        if self.sounds_enabled:
            for sound in self.sounds.values():
                sound.set_volume(volume)
```

## Performance Optimization and Caching

### 1. Database Query Optimization
```python title="hangmandatabase.py" showLineNumbers{1}
def optimize_database_performance(self):
    """Optimize database for better performance"""
    with sqlite3.connect(self.db_path) as conn:
        # Create comprehensive indexes
        indexes = [
            "CREATE INDEX IF NOT EXISTS idx_game_history_player_id ON game_history(player_id)",
            "CREATE INDEX IF NOT EXISTS idx_game_history_created_at ON game_history(created_at)",
            "CREATE INDEX IF NOT EXISTS idx_game_history_won ON game_history(won)",
            "CREATE INDEX IF NOT EXISTS idx_words_category ON words(category)",
            "CREATE INDEX IF NOT EXISTS idx_words_difficulty ON words(difficulty)",
            "CREATE INDEX IF NOT EXISTS idx_users_username ON users(username)",
            "CREATE INDEX IF NOT EXISTS idx_player_achievements_player_id ON player_achievements(player_id)"
        ]
        
        for index_sql in indexes:
            conn.execute(index_sql)
        
        # Analyze tables for query optimization
        conn.execute("ANALYZE")
        
        # Set pragmas for better performance
        conn.execute("PRAGMA cache_size = 10000")
        conn.execute("PRAGMA temp_store = MEMORY")
        conn.execute("PRAGMA journal_mode = WAL")

import functools
import time

class ResultCache:
    def __init__(self, ttl_seconds: int = 300):
        self.cache = {}
        self.ttl = ttl_seconds
    
    def get(self, key: str):
        """Get cached result"""
        if key in self.cache:
            result, timestamp = self.cache[key]
            if time.time() - timestamp < self.ttl:
                return result
            else:
                del self.cache[key]
        return None
    
    def set(self, key: str, value):
        """Set cached result"""
        self.cache[key] = (value, time.time())
    
    def clear(self):
        """Clear cache"""
        self.cache.clear()

# Global cache instance
result_cache = ResultCache()

def cached_db_query(cache_key_func):
    """Decorator for caching database queries"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            cache_key = cache_key_func(*args, **kwargs)
            cached_result = result_cache.get(cache_key)
            
            if cached_result is not None:
                return cached_result
            
            result = func(*args, **kwargs)
            result_cache.set(cache_key, result)
            return result
        
        return wrapper
    return decorator

@cached_db_query(lambda self, player_id: f"player_stats_{player_id}")
def get_player_stats_cached(self, player_id: int) -> Dict:
    """Cached version of get_player_stats"""
    return self.get_player_stats(player_id)
```

This comprehensive hangman game demonstrates advanced database integration, user management, game mechanics, and modern GUI development. The system provides enterprise-level features while maintaining an engaging gaming experience. 🎮🎯
